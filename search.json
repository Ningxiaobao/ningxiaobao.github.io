[{"title":"go基础","url":"/2019/02/18/go基础/","content":"## GO 学习\n\n\n\n### 1. GO 程序基础\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   /* 这是我的第一个简单的程序 */\n   fmt.Println(\"Hello, World!\")\n}\n```\n\n程序分析：\n\n1. 第一行代码 *package main* 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。\n2. 下一行 *import \"fmt\"* 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。\n3. 下一行 *func main()* 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。\n4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。\n5. 下一行 *fmt.Println(...)* 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。 \n   使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。 \n   Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。\n6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。\n\n**注意**： go 语言中 **{**  不能单独放在一行，否则代码在运行时会产生错误\n\n### 2. Go 标记\n\nGo 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：\n\n#### 行分隔符\n\n在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。\n\n如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。\n\n#### 注释\n\n注释不会被编译，每一个包应该有相关注释。\n\n单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：\n\n```go\n// 单行注释\n/*\n Author by 菜鸟教程\n 我是多行注释\n */\n```\n\n#### 标识符\n\n标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字\n\n#### 关键字\n\n下面列举了 Go 代码中会使用到的 25 个关键字或保留字：\n\n| break    | default     | func   | interface | select |\n| -------- | ----------- | ------ | --------- | ------ |\n| case     | defer       | go     | map       | struct |\n| chan     | else        | goto   | package   | switch |\n| const    | fallthrough | if     | range     | type   |\n| continue | for         | import | return    | var    |\n\n除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：\n\n| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |\n| ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |\n| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |\n| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |\n| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |\n\n程序一般由关键字、常量、变量、运算符、类型和函数组成。\n\n程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。\n\n程序中可能会使用到这些标点符号：.、,、;、: 和 …。\n\n#### Go 语言的空格\n\nGo 语言中变量的声明必须使用空格隔开，如：\n\n```go\nvar age int;\n```\n\n语句中适当使用空格能让程序更易阅读。\n\n无空格：\n\n```go\nfruit=apples+oranges;\n```\n\n在变量与运算符间加入空格，程序看起来更加美观，如：\n\n```go\nfruit = apples + oranges; \n```\n\n### 3. Go 语言数据类型\n\nGo 语言按类别有以下几种数据类型：\n\n| 序号 | 类型和描述                                                   |\n| ---- | ------------------------------------------------------------ |\n| 1    | **布尔型** 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |\n| 2    | **数字类型** 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 |\n| 3    | **字符串类型:** 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 |\n| 4    | **派生类型:** 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 |\n\n### 4. Go 语言变量\n\n变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。\n\nGo 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。\n\n声明变量的一般形式是使用 var 关键字 [ var  + 变量名 + 数据类型 ]：\n\n```go\nvar identifier type\n```\n\n#### 变量声明\n\n第一种，指定变量类型，声明后若不赋值，使用默认值。\n\n```\nvar v_name v_type\nv_name = value\n```\n\n第二种，根据值自行判定变量类型。\n\n```\nvar v_name = value\n```\n\n第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误,而且这种不带声明格式的 **只能在函数体中出现**。\n\n```\nv_name := value\n\n// 例如\nvar a int = 10\nvar b = 10\nc := 10\n\n```\n\n#### 多变量声明\n\n```go\n//类型相同多个变量, 非全局变量\nvar vname1, vname2, vname3 type\nvname1, vname2, vname3 = v1, v2, v3\n\nvar vname1, vname2, vname3 = v1, v2, v3 //和python很像,不需要显示声明类型，自动推断\n\n//这种不带声明格式的只能在函数体中出现\nvname1, vname2, vname3 := v1, v2, v3 //出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误\n\n// 这种因式分解关键字的写法一般用于声明全局变量\nvar (\n    vname1 v_type1\n    vname2 v_type2\n)\n\n```\n\n#### 值类型和引用类型\n\n所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值\n\n当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝\n\n可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。\n\n内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。\n\n更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。\n\n一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。\n\n这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。\n\n同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。\n\n当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。\n\n如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。\n\n#### 简短形式，使用 := 赋值操作符\n\n:= 是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。\n\n**全局变量是允许声明但不使用 **\n\n如果你想要交换两个变量的值，则可以简单地使用 **a, b = b, a**，两个变量的类型必须是相同。\n\n空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。\n\n_ 实际上是一个只写变量，你不能得到它的值。这样做是因为  **Go 语言中你必须使用所有被声明的变量**，但有时你并不需要使用从一个函数得到的所有返回值。\n\n### 5. Go 语言常量\n\n常量是一个简单值的标识符，在程序运行时，不会被修改的量。\n\n常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n\n常量的定义格式：\n\n```\nconst identifier [type] = value\n\n```\n\n你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型\n\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过\n\n**在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。**\n\n#### iota 用法\n\niota 表示从 0 开始自动加 1\n\n```go\nconst (\n    a = iota\n    b\n    c\n)\n\n```\n\n**注意：**\n\n```\na = \"hello\"\nunsafe.Sizeof(a)\n\n```\n\n输出结果为：16\n\n字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。\n\n### 6. Go 语言运算符\n\n#### 指针运算符\n\n下表列出了Go语言的其他运算符。\n\n| 运算符 | 描述             | 实例                       |\n| ------ | ---------------- | -------------------------- |\n| &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |\n| *      | 指针变量。       | *a; 是一个指针变量         |\n\nGO 语言具有指针的概念\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var a int = 4\n   var ptr *int\n\n   /* 运算符实例 */\n   fmt.Printf(\"第 1 行 - a 变量类型为 = %T\\n\", a );\n\n   /*  & 和 * 运算符实例 */\n   ptr = &a    /* 'ptr' 包含了 'a' 变量的地址 */\n   fmt.Printf(\"a 的值为  %d\\n\", a);\n   fmt.Printf(\"*ptr 为 %d\\n\", *ptr);\n}\n\n```\n\n### 7.  Go 语言条件语句\n\n| 语句                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [if 语句](http://www.runoob.com/go/go-if-statement.html)     | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |\n| [if...else 语句](http://www.runoob.com/go/go-if-else-statement.html) | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |\n| [if 嵌套语句](http://www.runoob.com/go/go-nested-if-statements.html) | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |\n| [switch 语句](http://www.runoob.com/go/go-switch-statement.html) | **switch** 语句用于基于不同条件执行不同动作。                |\n| [select 语句](http://www.runoob.com/go/go-select-statement.html) | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |\n\n### 8. Go 语言循环语句\n\n#### 无限循环\n\n如过循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for true  {\n        fmt.Printf(\"这是无限循环。\\n\");\n    }\n}\n\n```\n\n### 9. Go 语言函数\n\nGo 语言最少有个 main() 函数。\n\n函数声明告诉了编译器函数的名称，返回类型，和参数。\n\n#### 函数定义\n\nGo 语言函数定义格式如下：\n\n```go\nfunc function_name( [parameter list] ) [return_types] {\n   函数体\n}\n\n```\n\n函数定义解析：\n\n- func：函数由 func 开始声明\n- function_name：函数名称，函数名和参数列表一起构成了函数签名。\n- parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。\n- return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。\n- 函数体：函数定义的代码集合。\n\n例子:\n\n```go\n/* 函数返回两个数的最大值 */\nfunc max(num1, num2 int) (int) {\n   /* 声明局部变量 */\n   var result int\n\n   if (num1 > num2) {\n      result = num1\n   } else {\n      result = num2\n   }\n   return result \n}\n\n```\n\n#### 函数返回多个值\n\nGo 函数可以返回多个值，例如：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n   return y, x\n}\n\nfunc main() {\n   a, b := swap(\"Mahesh\", \"Kumar\")\n   fmt.Println(a, b)\n}\n\n```\n\n#### 函数参数\n\n函数如果使用参数，该变量可称为函数的形参。\n\n形参就像定义在函数体内的局部变量。\n\n调用函数，可以通过两种方式来传递参数：\n\n| 传递类型                                                     | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [值传递](http://www.runoob.com/go/go-function-call-by-value.html) | 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |\n| [引用传递](http://www.runoob.com/go/go-function-call-by-reference.html) | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 |\n\n默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。\n\n#### Go 语言函数作为值\n\nGo 语言可以很灵活的创建函数，并作为值使用：\n\n```go\npackage main\n\nimport (\n   \"fmt\"\n   \"math\"\n)\n\nfunc main(){\n   /* 声明函数变量 */\n   getSquareRoot := func(x float64) float64 {\n      return math.Sqrt(x)\n   }\n\n   /* 使用函数 */\n   fmt.Println(getSquareRoot(9))\n\n}\n\n```\n\n#### Go 语言函数闭包\n\nGo 语言支持匿名函数，可作为闭包。匿名函数是一个\"内联\"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc getSequence() func() int {\n   i:=0\n   return func() int {\n      i+=1\n     return i  \n   }\n}\n\nfunc main(){\n   /* nextNumber 为一个函数，函数 i 为 0 */\n   nextNumber := getSequence()  \n\n   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   \n   /* 创建新的函数 nextNumber1，并查看结果 */\n   nextNumber1 := getSequence()  \n   fmt.Println(nextNumber1())\n   fmt.Println(nextNumber1())\n}\n\n```\n\n由于闭包返回的是一个函数的结果，故在声明函数时，也必须声明返回结果为函数的结果\n\n```go\nfunc getSequence() func() int {                 //声明返回结果为函数的结果\n   i:=0\n   return func() int {                          //返回的是一个函数的结果\n      i+=1\n     return i  \n   }\n}\n\n```\n\n#### Go 语言函数方法\n\nGo 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：\n\n```go\nfunc (variable_name variable_data_type) function_name() [return_type]{\n   /* 函数体*/\n}\n\n```\n\n```go\npackage main\n\nimport (\n   \"fmt\"  \n)\n\n/* 定义结构体 */\ntype Circle struct {\n  radius float64\n}\n\nfunc main() {\n  var c1 Circle\n  c1.radius = 10.00\n  fmt.Println(\"圆的面积 = \", c1.getArea())\n}\n\n//该 method 属于 Circle 类型对象中的方法\nfunc (c Circle) getArea() float64 {\n  //c.radius 即为 Circle 类型对象中的属性\n  return 3.14 * c.radius * c.radius\n}\n\n```\n\n### 10.Go 语言变量作用域\n\n作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。\n\nGo 语言中变量可以在三个地方声明：\n\n- 函数内定义的变量称为局部变量\n- 函数外定义的变量称为全局变量\n- 函数定义中的变量称为形式参数\n\nGo 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑\n\n### 11.Go 语言数组\n\n#### 声明数组\n\nGo 语言数组声明需要指定元素类型及元素个数，语法格式如下：\n\n```\nvar variable_name [SIZE]variable_type\n\n```\n\n以上为一维数组的定义方式。例如以下定义了数组 balance 长度为 10 类型为 float32：\n\n```\nvar balance [10]float32\n\n```\n\n#### 初始化数组\n\n以下演示了数组初始化：\n\n```\nvar balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}\n\n```\n\n初始化数组中 {} 中的元素个数不能大于 [] 中的数字。\n\n如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：\n\n```\n var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}\n\n```\n\n该实例与上面的实例是一样的，虽然没有设置数组的大小。\n\n```\n balance[4] = 50.0\n\n```\n\n以上实例读取了第五个元素。数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n\n#### 初始化二维数组\n\n多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：\n\n```go\na = [3][4]int{  \n {0, 1, 2, 3} ,   /*  第一行索引为 0 */\n {4, 5, 6, 7} ,   /*  第二行索引为 1 */\n {8, 9, 10, 11},   /* 第三行索引为 2 */\n}\n\n```\n\n> 注意：\n>\n> 以上代码中倒数第二行的 } 必须要有逗号，因为最后一行的 }不能单独一行，也可以写成这样：\n>\n> ```\n> a = [3][4]int{  \n>  {0, 1, 2, 3} ,   /*  第一行索引为 0 */\n>  {4, 5, 6, 7} ,   /*  第二行索引为 1 */\n>  {8, 9, 10, 11}}   /* 第三行索引为 2 */\n> \n> ```\n\n#### Go 语言向函数传递数组\n\n如果想向函数传递数组参数,需要在函数定义时，声明形参为数组\n\n1.形参设定数组大小：\n\n```\nvoid myFunction(param [10]int)\n{\n...\n}\n\n```\n\n2.形参未设定数组大小：\n\n```\nvoid myFunction(param []int)\n{\n...\n}\n\n```\n\n### 12.Go 语言指针\n\nGo 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。\n\n#### 什么是指针\n\n一个指针变量指向了一个值的内存地址。\n\n类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：\n\n```\nvar var_name *var-type\n\n```\n\nvar-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：\n\n```\nvar ip *int        /* 指向整型*/\nvar fp *float32    /* 指向浮点型 */\n\n```\n\n#### Go 空指针\n\n当一个指针被定义后没有分配到任何变量时，它的值为 nil。\n\nnil 指针也称为空指针。\n\nnil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。\n\n一个指针变量通常缩写为 ptr\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var  ptr *int\n\n   fmt.Printf(\"ptr 的值为 : %x\\n\", ptr  )\n}  \n\n结果 ： ptr 的值为 : 0\n\n```\n\n空指针判断：\n\n```\nif(ptr != nil)     /* ptr 不是空指针 */\nif(ptr == nil)     /* ptr 是空指针 */\n\n```\n\n#### Go 语言指针数组\n\n以下声明了整型指针数组：\n\n```\nvar ptr [MAX]*int;\n\n```\n\nptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：\n\n```go\npackage main\n\nimport \"fmt\"\n\nconst MAX int = 3\n\nfunc main() {\n   a := []int{10,100,200}\n   var i int\n   var ptr [MAX]*int;\n\n   for  i = 0; i < MAX; i++ {\n      ptr[i] = &a[i] /* 整数地址赋值给指针数组 */\n   }\n\n   for  i = 0; i < MAX; i++ {\n      fmt.Printf(\"a[%d] = %d\\n\", i,*ptr[i] )\n   }\n}\n\n```\n\n#### Go 语言指向指针的指针\n\n如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n\n当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：\n\n![](http://www.runoob.com/wp-content/uploads/2015/06/pointer_to_pointer.jpg)\n\n\n\n指向指针的指针变量声明格式如下：\n\n```\nvar ptr **int;\n\n```\n\n以上指向指针的指针变量为整型。\n\n访问指向指针的指针变量值需要使用两个 * 号，如下所示：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n   var a int\n   var ptr *int\n   var pptr **int\n\n   a = 3000\n\n   /* 指针 ptr 地址 */\n   ptr = &a\n\n   /* 指向指针 ptr 地址 */\n   pptr = &ptr\n\n   /* 获取 pptr 的值 */\n   fmt.Printf(\"变量 a = %d\\n\", a )\n   fmt.Printf(\"指针变量 *ptr = %d\\n\", *ptr )\n   fmt.Printf(\"指向指针的指针变量 **pptr = %d\\n\", **pptr)\n}\n\n```\n\n#### Go 语言指针作为函数参数\n\nGo 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。\n\n以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值 [即：不改变指针指向的情况下，改变变量的值]:\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   /* 定义局部变量 */\n   var a int = 100\n   var b int= 200\n\n   fmt.Printf(\"交换前 a 的值 : %d\\n\", a )\n   fmt.Printf(\"交换前 b 的值 : %d\\n\", b )\n\n   /* 调用函数用于交换值\n   * &a 指向 a 变量的地址\n   * &b 指向 b 变量的地址\n   */\n   swap(&a, &b);\n\n   fmt.Printf(\"交换后 a 的值 : %d\\n\", a )\n   fmt.Printf(\"交换后 b 的值 : %d\\n\", b )\n}\n\nfunc swap(x *int, y *int) {\n   // *x, *y = *y, *x\n   var temp int\n   temp = *x    /* 保存 x 地址的值 */\n   *x = *y      /* 将 y 赋值给 x */\n   *y = temp    /* 将 temp 赋值给 y */\n}\n\n```\n\n### 13. Go 语言结构体\n\n#### 定义结构体\n\n结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体有中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：\n\n**注意：**在结构体定义中，可以省略 var 关键字\n\n```go\ntype struct_variable_type struct {\n   member definition;\n   member definition;\n   ...\n   member definition;\n}\n\n```\n\n一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：\n\n```go\nvariable_name := structure_variable_type {value1, value2...valuen}\n或\nvariable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}\n\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Books struct {\n   title string\n   author string\n   subject string\n   book_id int\n}\n\nfunc main() {\n    \n    // 创建一个新的结构体\n    fmt.Println(Books{\"Go 语言\", \"www.runoob.com\", \"Go 语言教程\", 6495407})\n\n    // 忽略的字段为 0 或 空\n   fmt.Println(Books{title: \"Go 语言\", author: \"www.runoob.com\"})\n}\n\n```\n\n#### 访问结构体成员\n\n如果要访问结构体成员，需要使用点号 **.** 操作符，格式为：\n\n```\n结构体.成员名\"\n\n```\n\n结构体类型变量使用 struct 关键字定义\n\n#### 结构体作为函数参数\n\n可以像其他数据类型一样将结构体类型作为参数传递给函数\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Books struct {\n   title string\n   author string\n   subject string\n   book_id int\n}\n\nfunc main() {\n   var Book1 Books        /* 声明 Book1 为 Books 类型 */\n   \n   /* book 1 描述 */\n   Book1 = Books{\"Go 语言\", \"www.runoob.com\", \"Go 语言教程\", 6495407}\n   \n   /* 打印 Book1 信息 */\n   printBook(Book1)\n\n}\n\nfunc printBook( book Books ) {\n   fmt.Printf( \"Book title : %s\\n\", book.title);\n   fmt.Printf( \"Book author : %s\\n\", book.author);\n   fmt.Printf( \"Book subject : %s\\n\", book.subject);\n   fmt.Printf( \"Book book_id : %d\\n\", book.book_id);\n}\n\n```\n\n#### 结构体指针\n\n可以定义指向结构体的指针类似于其他指针变量，格式如下：\n\n```\nvar struct_pointer *Books\n\n```\n\n以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 & 符号放置于结构体变量前：\n\n```\nstruct_pointer = &Book1;\n\n```\n\n使用结构体指针访问结构体成员，使用 \".\" 操作符：\n\n```\nstruct_pointer.title;\n\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Books struct {\n   title string\n   author string\n   subject string\n   book_id int\n}\n\nfunc main() {\n\n   /* book 1 描述 */\n   Book1 := Books{\"Go 语言\", \"www.runoob.com\", \"Go 语言教程\", 6495407}\n   \n   /* 打印 Book1 信息 */\n   printBook(&Book1)\n\n}\nfunc printBook( book *Books ) {\n   fmt.Printf( \"Book title : %s\\n\", book.title);\n   fmt.Printf( \"Book author : %s\\n\", book.author);\n   fmt.Printf( \"Book subject : %s\\n\", book.subject);\n   fmt.Printf( \"Book book_id : %d\\n\", book.book_id);\n}\n\n```\n\n**注意**：在访问结构体成员时，无论使用结构体指针访问，还是结构体访问，访问的方式均为 **结构体.结构体变量**\n\n### 14. Go 语言切片(Slice)\n\nGo 语言切片是对数组的抽象。\n\nGo 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\"),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大\n\n#### 定义切片\n\n你可以声明一个未指定大小的数组来定义切片：\n\n```\nvar identifier []type\n\n```\n\n**切片不需要说明长度**。\n\n或使用make()函数来创建切片:\n\n```\nvar slice1 []type = make([]type, len)\n\n也可以简写为\n\nslice1 := make([]type, len)\n\n```\n\n也可以指定容量，其中capacity为可选参数。\n\n```\nmake([]T, length, capacity)\n\n```\n\n这里 len 是数组的长度并且也是切片的初始长度。\n\n#### 切片初始化\n\n```\ns :=[] int {1,2,3} \n\n```\n\n直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3\n\n```\ns := arr[:] \n\n```\n\n初始化切片s,是数组arr的引用\n\n```\ns := arr[startIndex:endIndex] \n\n```\n\n将arr中从下标 startIndex 到 **endIndex-1** 下的元素创建为一个新的切片\n\n```\ns := arr[startIndex:] \n\n```\n\n缺省endIndex时将表示一直到arr的最后一个元素\n\n```\ns := arr[:endIndex] \n\n```\n\n缺省startIndex时将表示从arr的第一个元素开始\n\n```\ns1 := s[startIndex:endIndex] \n\n```\n\n通过切片s初始化切片s1\n\n```\ns :=make([]int,len,cap) \n\n```\n\n通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片\n\n#### len() 和 cap() 函数\n\n切片是可索引的，并且可以由 len() 方法获取长度。\n\n切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。\n\n**而 cap() 的值，切片每增加一个 int 型数据，空间值增长 2 **\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var numbers = make([]int,3,5)\n\n   printSlice(numbers)\n}\n\nfunc printSlice(x []int){\n   fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\n}\n\n结果 ： len=3 cap=5 slice=[0 0 0]\n\n```\n\n#### 空(nil)切片\n\n一个切片在未初始化之前默认为 nil，长度为 0，实例如下：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var numbers []int\n\n   printSlice(numbers)\n\n   if(numbers == nil){\n      fmt.Printf(\"切片是空的\")\n   }\n}\n\nfunc printSlice(x []int){\n   fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\n}\n\n```\n\n#### 切片截取\n\n可以通过设置下限及上限来设置截取切片 *[lower-bound:upper-bound]*\n\n#### append() 和 copy() 函数\n\n如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。\n\n下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var numbers []int\n   printSlice(numbers)\n\n   /* 允许追加空切片 */\n   numbers = append(numbers, 0)\n   printSlice(numbers)\n\n   /* 同时添加多个元素 */\n   numbers = append(numbers, 1,2,3,4)\n   printSlice(numbers)\n\n   /* 创建切片 numbers1 是之前切片的两倍容量*/\n   numbers1 := make([]int, len(numbers), (cap(numbers))*2)\n\n   /* 拷贝 numbers 的内容到 numbers1 */\n   copy(numbers1,numbers)\n   printSlice(numbers1)   \n}\n\nfunc printSlice(x []int){\n   fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\n}\n\n```\n\n### 15. Go 语言范围(Range)\n\nGo 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。\n\n```go\npackage main\nimport \"fmt\"\nfunc main() {\n    //这是我们使用range去求一个slice的和。使用数组跟这个很类似\n    nums := []int{2, 3, 4}\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    fmt.Println(\"sum:\", sum)\n    //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符\"_\"省略了。有时侯我们确实需要知道它的索引。\n    for i, num := range nums {\n        if num == 3 {\n            fmt.Println(\"index:\", i)\n        }\n    }\n    //range也可以用在map的键值对上。\n    kvs := map[string]string{\"a\": \"apple\", \"b\": \"banana\"}\n    for k, v := range kvs {\n        fmt.Printf(\"%s -> %s\\n\", k, v)\n    }\n    //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。\n    for i, c := range \"go\" {\n        fmt.Println(i, c)\n    }\n}\n\n```\n\n### 16.Go 语言Map(集合)\n\nMap 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。\n\nMap 是一种集合，所以我们可以像迭代数组和切片那样迭代它。\n\n注意点：**Map 是无序的，我们无法决定它的返回顺序**，这是因为 Map 是使用 hash 表来实现的。\n\n#### 定义 Map\n\n可以使用内建函数 make 也可以使用 map 关键字来定义 Map:\n\n```\n/* 声明变量，默认 map 是 nil */\nvar map_variable map[key_data_type]value_data_type\n\n/* 使用 make 函数,初始化map */\nmap_variable := make(map[key_data_type]value_data_type)\n\n```\n\n如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    /*创建集合 */\n    var countryCapitalMap map[string]string \n    \n    /* 如果不适用 make 函数初始化，将会报错*/\n    countryCapitalMap = make(map[string]string)\n\n    /* map插入key - value对,各个国家对应的首都 */\n    countryCapitalMap [ \"France\" ] = \"Paris\"\n    countryCapitalMap [ \"Italy\" ] = \"罗马\"\n    countryCapitalMap [ \"Japan\" ] = \"东京\"\n    countryCapitalMap [ \"India \" ] = \"新德里\"\n\n    /*使用键输出地图值 */ \n    for country := range countryCapitalMap {\n        fmt.Println(country, \"首都是\", countryCapitalMap [country])\n    }\n    \n    /*如果使用以下方法\n    for country,v := range countryCapitalMap {\n      fmt.Println(country, \"首都是\", v)\n    则输出的结果将会是无序的。\n    */\n\n    /*查看元素在集合中是否存在 */\n    captial, ok := countryCapitalMap [ \"美国\" ]\n    /*如果确定是真实的,则存在,否则不存在 */\n    if (ok) {\n        fmt.Println(\"美国的首都是\", captial)\n    } else {\n        fmt.Println(\"美国的首都不存在\")\n    }\n}\n\n```\n\n#### delete() 函数\n\ndelete() 函数用于删除集合的元素, 参数为 map 和其对应的 key\n\n```go\ncountryCapitalMap := map[string]string{\"France\": \"Paris\", \"Italy\": \"Rome\", \"Japan\": \"Tokyo\", \"India\": \"New delhi\"}\n\n/*删除元素*/\ndelete(countryCapitalMap, \"France\")\nfmt.Println(\"法国条目被删除\")\n\n```\n\n### 17. Go 语言递归函数\n\n递归，就是在运行的过程中调用自己。\n\n语法格式如下：\n\n```go\nfunc recursion() {\n   recursion() /* 函数调用自身 */\n}\n\nfunc main() {\n   recursion()\n}\n\n```\n\n#### 阶乘\n\n以下实例通过 Go 语言的递归函数实例阶乘：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Factorial(n uint64)(uint64) {\n    if (n > 0) {\n        result := n * Factorial(n-1)\n        return result\n    }\n    return 1\n}\n\nfunc main() {  \n    var i int = 15\n    fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i)))\n}\n\n```\n\n#### 斐波那契数列\n\n以下实例通过 Go 语言的递归函数实现斐波那契数列：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n  if n < 2 {\n   return n\n  }\n  return fibonacci(n-2) + fibonacci(n-1)\n}\n\nfunc main() {\n    var i int\n    for i = 0; i < 10; i++ {\n       fmt.Printf(\"%d\\t\", fibonacci(i))\n    }\n}\n\n```\n\n### 18. Go 语言类型转换\n\n类型转换用于将一种数据类型的变量转换为另外一种类型的变量, Go 语言类型转换基本格式如下：\n\n```\ntype_name(expression)\n\n```\n\ntype_name 为类型，expression 为表达式。\n\n### 19. Go 语言接口\n\nGo 语言提供了一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Phone interface {\n    call()\n}\n\ntype NokiaPhone struct {\n}\n\nfunc (nokiaPhone NokiaPhone) call() {\n    fmt.Println(\"I am Nokia, I can call you!\")\n}\n\ntype IPhone struct {\n}\n\nfunc (iPhone IPhone) call() {\n    fmt.Println(\"I am iPhone, I can call you!\")\n}\n\nfunc main() {\n    var phone Phone\n\n    nokiaPhone := NokiaPhone{}\n    nokiaPhone.call()\n    \n    phone = new(NokiaPhone)\n    phone.call()\n\n    phone = new(IPhone)\n    phone.call()\n\n}\n\n```\n\n在上面的例子中，我们定义了一个接口 Phone，接口里面有一个方法 call()。然后我们在 main 函数里面定义了一个Phone 类型变量，并分别为之赋值为 NokiaPhone 和 IPhone。然后调用 call() 方法\n\n### 20. Go 错误处理\n\nGo 语言通过内置的错误接口提供了非常简单的错误处理机制。\n\nerror类型是一个接口类型，这是它的定义：\n\n```go\ntype error interface {\n    Error() string\n}\n\n```\n\n我们可以在编码中通过实现 error 接口类型来生成错误信息。\n\n函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：\n\n```go\nfunc Sqrt(f float64) (float64, error) {\n    if f < 0 {\n        return 0, errors.New(\"math: square root of negative number\")\n    }\n    // 实现\n}\n\n```\n\npanic 与 recover,一个用于主动抛出错误，一个用于捕获panic抛出的错误。\n\n**概念**\n\npanic 与 recover 是 Go 的两个内置函数，这两个内置函数用于处理 Go 运行时的错误，panic 用于主动抛出错误，recover 用来捕获 panic 抛出的错误。\n\n- 引发`panic`有两种情况，一是程序主动调用，二是程序产生运行时错误，由运行时检测并退出。\n- 发生`panic`后，程序会从调用`panic`的函数位置或发生`panic`的地方立即返回，逐层向上执行函数的`defer`语句，然后逐层打印函数调用堆栈，直到被`recover`捕获或运行到最外层函数。\n- `panic`不但可以在函数正常流程中抛出，在`defer`逻辑里也可以再次调用`panic`或抛出`panic`。`defer`里面的`panic`能够被后续执行的`defer`捕获。\n- `recover`用来捕获`panic`，阻止`panic`继续向上传递。`recover()`和`defer`一起使用，但是`defer`只有在后面的函数体内直接被掉用才能捕获`panic`来终止异常，否则返回`nil`，异常继续向外传递。**此句不是很理解**\n\n多个panic只会捕捉最后一个：\n\n```go\npackage main\nimport \"fmt\"\nfunc main(){\n    defer func(){\n        err := recover() \n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n    defer func(){\n        panic(\"three\")\n    }()\n    defer func(){\n        panic(\"two\")\n    }()\n    panic(\"one\")\n}\n\n```\n\n**使用场景**\n\n一般情况下有两种情况用到：\n\n-  程序遇到无法执行下去的错误时，抛出错误，主动结束运行。\n-  在调试程序时，通过 panic 来打印堆栈，方便定位错误。\n\n### 21. Go 并发\n\nGo 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。\n\ngoroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。\n\ngoroutine 语法格式：\n\n```\ngo 函数名( 参数列表 )\n\n```\n\nGo 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。**同一个程序中的所有 goroutine 共享同一个地址空间**。\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n        \"time\"\n)\n\nfunc say(s string) {\n        for i := 0; i < 5; i++ {\n                time.Sleep(100 * time.Millisecond)\n                fmt.Println(s)\n        }\n}\n\nfunc main() {\n        go say(\"world\")\n        say(\"hello\")\n}\n\n```\n\n#### 通道（channel）\n\n通道（channel）是用来传递数据的一个数据结构。\n\n通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 `<-` 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。\n\n```go\nch <- v    // 把 v 发送到通道 ch\nv := <-ch  // 从 ch 接收数据\n           // 并把值赋给 v\n\n```\n\n声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：\n\n```go\nch := make(chan int)\n\n```\n\n**注意**：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须又接收端相应的接收数据。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n        sum := 0\n        for _, v := range s {\n                sum += v\n        }\n        c <- sum // 把 sum 发送到通道 c\n}\n\nfunc main() {\n        s := []int{7, 2, 8, -9, 4, 0}\n\n        c := make(chan int)\n        go sum(s[:len(s)/2], c)\n        go sum(s[len(s)/2:], c)\n        x, y := <-c, <-c // 从通道 c 中接收\n\n        fmt.Println(x, y, x+y)\n}\n\n结果： -5 17 12\n\n```\n\n#### 通道缓冲区\n\n通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：\n\n```\nch := make(chan int, 100)\n\n```\n\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n\n不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。\n\n**注意**：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 这里我们定义了一个可以存储整数类型的带缓冲通道\n        // 缓冲区大小为2\n        ch := make(chan int, 2)\n\n        // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据\n        // 而不用立刻需要去同步读取数据\n        ch <- 1\n        ch <- 2\n\n        // 获取这两个数据\n        fmt.Println(<-ch)\n        fmt.Println(<-ch)\n}\n\n```\n\n#### Go 遍历通道与关闭通道\n\nGo 通过 range 关键字来实现遍历读取道的数据，类似于与数组或切片。格式如下：\n\n```go\nv, ok := <-ch\n\n```\n\n如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 **close()** 函数来关闭。\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n        x, y := 0, 1\n        for i := 0; i < n; i++ {\n                c <- x\n                x, y = y, x+y\n        }\n        close(c)\n}\n\nfunc main() {\n        c := make(chan int, 10)\n        go fibonacci(cap(c), c)\n        /* range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个\n         数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据\n         之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不\n         会结束，从而在接收第 11 个数据的时候就阻塞了。*/\n        for i := range c {\n                fmt.Println(i)\n        }\n}\n\n```\n\ngoroutine 是 golang 中在语言级别实现的轻量级线程，仅仅利用 go 就能立刻起一个新线程。多线程会引入线程之间的同步问题，在 golang 中可以使用 channel 作为同步的工具。\n\n通过 channel 可以实现两个 goroutine 之间的通信。\n\n创建一个 channel， make(chan TYPE {, NUM}) TYPE 指的是 channel 中传输的数据类型，第二个参数是可选的，指的是 channel 的容量大小。\n\n向 channel 传入数据， CHAN <- DATA ， CHAN 指的是目的 channel 即收集数据的一方， DATA 则是要传的数据。\n\n从 channel 读取数据， DATA := <-CHAN ，和向 channel 传入数据相反，在数据输送箭头的右侧的是 channel，形象地展现了数据从隧道流出到变量里。\n\n我们单独写一个 say2 函数来跑 goroutine，并且 Sleep 时间设置为150 毫秒，比主函数暂停时间长：\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"time\"\n)\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s, (i+1)*100)\n    }\n}\nfunc say2(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(150 * time.Millisecond)\n        fmt.Println(s, (i+1)*150)\n    }\n}\nfunc main() {\n    go say2(\"world\")\n    say(\"hello\")\n}\n\n结果：\nhello 100\nworld 150\nhello 200\nhello 300\nworld 300\nhello 400\nworld 450\nhello 500\n\n```\n\n问题来了，say2 只执行了 3 次，而不是设想的 5 次\n\n因为 goroutine 还没来得及跑完 5 次的时候，主函数已经退出了。\n\n阻止主函数的结束，要等待 goroutine 执行完成之后，再退出主函数：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s, (i+1)*100)\n    }\n}\nfunc say2(s string, ch chan int) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(150 * time.Millisecond)\n        fmt.Println(s, (i+1)*150)\n    }\n    ch <- 0\n    close(ch)\n}\n\nfunc main() {\n    ch := make(chan int)\n    go say2(\"world\", ch)\n    say(\"hello\")\n    fmt.Println(<-ch)\n}\n\n```\n\n引入一个信道，默认的，信道的存消息和取消息都是阻塞的，在 goroutine 中执行完成后给信道一个值 0，则主函数会一直等待信道中的值，一旦信道有值，主函数才会结束。\n"},{"title":"Hello World","url":"/2019/02/18/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]