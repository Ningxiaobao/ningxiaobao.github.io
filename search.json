[{"title":"MySQL二进制安装手册","url":"/2019/02/22/MySQL二进制安装手册/","content":"## 安装部分\n\n### 1.建账户\n\n`groupadd mysql`\n\n`useradd -g mysql -d /usr/local/mysql -s /sbin/nologin -M mysql`\n\n-g<群组>：指定用户所属的群组\n\n-d<登入目录>：指定用户登入时的启始目录；\n\n-s<shell>：指定用户登入后所使用的shell；\n\n-M：不要自动建立用户的登入目录；\n\n### 2.mysql 基本安装\n\n`apt-get install libaio1`\n\n libaio是Linux下的一个异步非阻塞接口,它提供了以异步非阻塞方式来读写文件的方式,读写效率比较高\n\n`mkdir /opt/mysql`\n\n`cd /opt/mysql/`\n\n/usr：系统级的目录，可以理解为C:/Windows/\n\n/usr/lib理解为C:/Windows/System32\n\n/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。\n\n/opt：用户级的程序目录，可以理解为D:/Software\n\n/usr/src：系统级的源码目录。\n\n/usr/local/src：用户级的源码目录。\n\n`wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz`\n\n`tar zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz`\n\n`ln -s /opt/mysql/mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql`\n\n建立软连接到 mysql 用户起始目录\n\n`chown -R mysql:mysql /usr/local/mysql`\n\n将目录 /usr/local/mysql 的数组和所属用户均修改为 mysql\n\n### 3.创建数据目录\n\n`mkdir -p /data/mysql/mysql3306/{data,logs,tmp}`\n\n`chown -R mysql:mysql /data/mysql/mysql3306/`\n\n### 4.添加用户 bin 目录到全局 bin 执行目录 [即:全局使用 mysql 相关命令]\n\n`echo \"export PATH=$PATH:/usr/local/mysql/bin\">>/etc/profile`\n\n`source /etc/profile`\n\n### 5.准备 my.cnf\n\n上传一份 my3306.cnf 到 /data/mysql/mysql3306/\n\n### 6.初始化\n\n`mysqld --defaults-file=/data/mysql/mysql3306/my3306.cnf --initialize`\n\n### 7.检查error.log\n\n`cat /data/mysql/mysql3306/data/error.log`\n\n## 使用部分\n\n### 1.启动 mysql\n\n`mysqld --defaults-file=/data/mysql/mysql3306/my3306.cnf &`\n\n### 2.检查有否 error\n\n`cat /data/mysql/mysql3306/data/error.log`\n\n### 3.获取随机密码\n\n`cat /data/mysql/mysql3306/data/error.log|grep password`\n\n### 4.登陆 mysql\n\n`mysql  --defaults-file=/data/mysql/mysql3306/my3306.cnf  -S /tmp/mysql3306.sock -uroot -p`\n\n### 5.修改密码\n\n`alter user user() identified by 'xmm';`\n或\n`set password = password('xxx');`\n\n## 关闭Mysql\n\n`ps aux |grep mysql |grep -v grep`\n\n`ss -tnl |grep 3306`\n\n### 通过 mysqladmin 关闭数据库\n\n1. `/usr/local/mysql/bin/mysqladmin -u root -p123456 -S /tmp/mysql3306.sock shutdown`\n\n### 通过 mysql 关闭数据库\n\n2. `mysql -S /tmp/mysql3306.sock -u root -p123456 -e 'shutdown' `\n\n### 查看结果\n\n`ss -tnl |grep 3306`\n\n`ps aux |grep mysql |grep -v grep`\n","tags":["MySQL"]},{"title":"基于hexo的博客搭建手册","url":"/2019/02/19/基于hexo的博客搭建手册/","content":"### Hexo 在 Github 中搭建博客系统\n\n参考网站：\n\n[1.一个很详细的搭建过程](http://blog.csdn.net/chwshuang/article/details/52350377)\n\n[2.一个朋友写的填坑指南](http://drops.blbana.cc/2016/12/05/Wordpress%E8%BF%81%E7%A7%BBhexo%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/)\n\n[3. git 基础（必看）](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n\n[4.安装 node.js ](http://blog.csdn.net/zijie_xiao/article/details/51114917)\n\n## 前言\n\n本次安装环境为：Ubuntu 14.04.5/Centos\n\n### 开始\n\n#### 一.了解 Hexo\n\nHexo 是一个基于 Node.js 快速、简洁且高效的一套博客管理系统\n\n主要有四大特性: \n\n- 快速自动生成全站静态页面 \n\n- 支持 Markdown 语法 \n\n- 一键部署到 Github Pages \n\n- 丰富的插件,支持 Jade、CoffeeScript 语言创建模板\n\n  \n\n#### 二.安装 Hexo\n\n##### 前提条件\n\n1.安装拥有一个 Github 账号 ,并且已经创建自己的github 的项目 [不会的看 git 基础](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n\n2.安装 Node.js ,安装 Git\n\n##### 安装 git\n\n```\nUbuntu:\n命令：sudo apt-get install git\n\nCentos:\n命令: sudo yum install git\n```\n\n安装完成后，还需要最后一步设置，在命令行输入：\t\t\t\n\n```\n命令： \n    git config --global user.name \"Your Name\"\n    git config --global user.email \"email@example.com\"\n```\n\n原因：因为 Git 是分布式版本控制系统，每个机器都必须自报家门\n\n##### 创建远程仓库\n\n第1步：创建 SSH Key。在 /home/youname 下，找到 .ssh 目录，进入目录，找到 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell，创建 SSH Key：\t\n\n```\n命令：ssh-keygen -t rsa -C \"123456789@qq.com\" (换成你的邮箱即可)\n```\n\n第2步：登陆 GitHub，打开 “Account settings” ，“SSH Keys” 页面： [该页面是很久以前的版本，安装时按现在页面添加即可]\n然后，点 “Add SSH Key” ，填上任意 Title ，在 Key 文本框里粘贴 id_rsa.pub 文件的内容：\n![](http://www.liaoxuefeng.com/files/attachments/001384908342205cc1234dfe1b541ff88b90b44b30360da000/0)\n点 “Add Key” ，你就应该看到已经添加的 Key：\n![](http://www.liaoxuefeng.com/files/attachments/0013849083502905a4caa2dc6984acd8e39aa5ae5ad6c83000/0)\n\n##### 添加远程库\n\n登陆 GitHub，然后，在右上角找到 “Create a new repo” 按钮，创建一个新的仓库,仓库名必须为：username.github.io\n![](http://www.liaoxuefeng.com/files/attachments/0013849084639042e9b7d8d927140dba47c13e76fe5f0d6000/0)\n在 Repository name 填入 username.github.io，其他保持默认设置，完成创建\n\n##### 测试链接\n\n```\n命令：ssh -T git@github.com\n```\n\n##### 安装 Node.js\n\n通过 apt-get 下载编译好的软件包：[访问官网下载](https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions)\n\n1.在终端执行以下两个命令\t\n\n```\nUbuntu:\n命令：curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -\n命令: sudo apt-get install -y nodejs\n\nCentos:\n命令:sudo yum install -y nodejs\n```\n\n2.同时还需要下载一个依赖工具\t\t\n\n```\nUbuntu:\n命令：sudo apt-get install -y build-essential\n     \nCentos:\n命令：sudo yum install make gcc gcc-c++ kernel-devel\n```\n\n3.下载完成后，可以查看 nodejs 与 npm 版本: \n\n```\n命令：nodejs -v \n命令：npm -v \n```\n\n4.Node.js安装好了后,执行以下命令\n\n```\n命令：sudo npm install -g  hexo-cli \n```\n\n5.安装完成后,创建一个网站目录,并将该目录定义为站点,比如 blog 目录\t\t\n\n```\n命令:\n     mkdir blog\n     cd blog\n     hexo init\n```\n\n6.启动站点\t\t\t\n\n```\n命令:hexo server -p 4000(你可以制定别的端口)\n```\n\n浏览器访问 http://localhost:4000/ 查看是否安装成功\n\n\n\n#### 三.部署到 Github\n\n##### 配置Github\n\n在 blog 目录,打开 _config.yml\t\n\n```\n命令:vim _config.yml\n```\n\n修改配置文件 _config.yml 中 deploy 下的内容\t\t\n\n```\n# Deployment\ndeploy:                                                   #deploy: 表示部署设置\n    type: git                                              #type:  部署类型,支持\n    repository: git@github.com:Ningxiaobao/ningxiaobao.github.io.git \n                                                           #repo:部署位置 git仓库项目的位置\n    branch: master\n```\n\n注意：Node.js对于配置文件要求严格，需要在 ：后面跟上一个空格！！！  冒号后必须有空格！！！\n\n##### 绑定自己的域名：\n\n1.进入blog的soure文件夹,新建一个名叫 CNAME(CNAME必须大写)的文件，然后在首行填入你需要的域名，\n\n```\n例如：blog.ningxiaobao.cn     [注意：前面没有http:// ]\n```\n\n2.在域名提供商那里解析域名，我在 [cloudXNS](https://www.cloudxns.net/Index/index.html ) 进行域名解析的\n3.添加一个 CNAME ，主机记录写 blog ，后面的记录值是：ningxiaobao.github.io；\n4.等待 DNS 解析刷新,可以通过[这里](http://www.17ce.com/)测试，DNS 解析是否生效\n\n##### 安装部署插件\n\n配置修改完成后,需要安装部署插件: \n安装 hexo-deployer-git 插件: 在blog目录执行以下命令\t\t\n\n```\n命令:npm install hexo-deployer-git --save\n```\n\n##### 编译部署\n\n```\n命令：\n      hexo clean      #清空缓存\n      hexo genarate   #生成静态页面至public目录   可以简写为：hexo g\n      hexo deploy     #将.deploy目录部署到GitHub 可以简写为：hexo d\n```\n\nhexo 常用命令：\n\n```\nhexo new \"postName\"                   #新建文章\nhexo new page \"pageName\"              #新建页面\nhexo generate                         #生成静态页面至public目录\nhexo server                           #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy                           #将.deploy目录部署到GitHub\n```\n\n##### 查看结果\n\n然后到你的 Github 上项目的主页,看看 master 分支上的代码更新时间\n\n#### 配置主题\n\n##### 选择主题\n\n可以从 [ Hexo 主题](https://hexo.io/themes/) 中选择自己喜欢主题。\n\n##### 下载主题\n\n点击图片,就会跳到这个主题的博客,看到实际的效果 \n要下载这个主题,就点击主题文字,进入主题 Github 页面,然后复制下载地址 \n\n进入blog目录,克隆主题到本地\n\n```\ngit clone https://github.com/tufu9441/[主题名]-hexo.git themes/主题名\n```\n\n注意：在安装主题的时候，需要将下载的主题源代码，放在了themes文件下的相应主题名文件夹下，否则会导致了一些文件路径出错\n\n##### 下载完成后，修改配置文件\n\n修改 blog 根目录的 _config.yml ,将 theme 的值修改为主题名\n\n```\n命令：\n     vim _config.yml\n\t ...\n\t # Extensions\n\t theme: maupassant\n```\n\n注意:某些主题依赖 jade 和 sass 插件,所以在配置好主题后,还要进行安装插件\n\n建议：安装上比较好，如果以后使用的某个主题需要该插件，就可以不必再安装了\n\n安装插件：\n\n```\n命令：\n      npm install hexo-renderer-jade --save\n      npm install hexo-renderer-sass --save\n```\n\n##### 查看\n\n清空缓存,然后启动服务器,在本地浏览器输入 localhost:4000 ,查看博客效果\n\n```\n命令：\n      hexo clean \n      hexo s --debug\n      hexo g\n      hexo d\n```\n\n##### 自定义\n\n要修改主题的内容,可以在主题的 Github 主页上查看详细介绍，可以修改 themes /主题名/_config.yml  文件\n\n#### 五.Wordpress迁移到Hexo\n\n##### 安装 hexo-migrator-wordpress 插件\n\n```\n命令：npm install hexo-migrator-wordpress --save\n```\n\n在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)。\n\n导入文件：\n\n```\nhexo migrate wordpress  wordpress导出文件在主机上的路径\n```\n\n执行完命令后发现文章已经以 markdown 的形式，存放在了 ~\\blog\\source\\_posts 文件下\n\n之后执行命令，将文章上传到 github 上\n\n```\n命令：\n      hexo clean\n      hexo g\n      hexo d\n```\n\n注意：如果 markdown 格式的文章存在语法错误，则无法通过编译，并报错\n\n#### 六.访问博客\n\n完成以上步骤后，通过浏览器输入 [blog.ningxiaobao.cn](http://blog.ningxiaobao.cn/) 就可以正常访问博客了\n留言板：我是用主题自带的多说，但具体如何配置，小宝也不是很清楚（但是我会在搞清楚，以后把该部分写进来）\n\n#### 七.注意事项及提醒\n\n对文件修改时，需要在 source 文件夹下进行修改，因为每次编译是以 source 文件下的内容为模板进行编译的，只是在public中进行修改的话，第二次编译后，之前的修改就会被覆盖掉。\n\n#### 结语\n\n本来已经有一个用 wordpress 搭建的博客了，恰逢今夜不想看书，而且朋友又写了一篇搭建过程，于是就抱着试一试的态度，搭一个玩玩，最后没想到自己竟也写一篇搭建文章。怎么说呢，如果你看到这，而且对你很有帮助，这样就够了\n\n我是泞小宝，一个懒惰的小白，我不知道我能做成什么，但既然我都可以，你必定行\n\n","tags":["blog"]},{"title":"go基础","url":"/2019/02/18/go基础/","content":"## GO 学习\n\n\n\n### 1. GO 程序基础\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   /* 这是我的第一个简单的程序 */\n   fmt.Println(\"Hello, World!\")\n}\n```\n\n程序分析：\n\n1. 第一行代码 *package main* 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。\n2. 下一行 *import \"fmt\"* 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。\n3. 下一行 *func main()* 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。\n4. 下一行 /*...*/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。\n5. 下一行 *fmt.Println(...)* 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。 \n   使用 fmt.Print(\"hello, world\\n\") 可以得到相同的结果。 \n   Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。\n6. 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。\n\n**注意**： go 语言中 **{**  不能单独放在一行，否则代码在运行时会产生错误\n\n### 2. Go 标记\n\nGo 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：\n\n#### 行分隔符\n\n在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。\n\n如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。\n\n#### 注释\n\n注释不会被编译，每一个包应该有相关注释。\n\n单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：\n\n```go\n// 单行注释\n/*\n Author by 菜鸟教程\n 我是多行注释\n */\n```\n\n#### 标识符\n\n标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字\n\n#### 关键字\n\n下面列举了 Go 代码中会使用到的 25 个关键字或保留字：\n\n| break    | default     | func   | interface | select |\n| -------- | ----------- | ------ | --------- | ------ |\n| case     | defer       | go     | map       | struct |\n| chan     | else        | goto   | package   | switch |\n| const    | fallthrough | if     | range     | type   |\n| continue | for         | import | return    | var    |\n\n除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：\n\n| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |\n| ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |\n| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |\n| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |\n| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |\n\n程序一般由关键字、常量、变量、运算符、类型和函数组成。\n\n程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。\n\n程序中可能会使用到这些标点符号：.、,、;、: 和 …。\n\n#### Go 语言的空格\n\nGo 语言中变量的声明必须使用空格隔开，如：\n\n```go\nvar age int;\n```\n\n语句中适当使用空格能让程序更易阅读。\n\n无空格：\n\n```go\nfruit=apples+oranges;\n```\n\n在变量与运算符间加入空格，程序看起来更加美观，如：\n\n```go\nfruit = apples + oranges; \n```\n\n### 3. Go 语言数据类型\n\nGo 语言按类别有以下几种数据类型：\n\n| 序号 | 类型和描述                                                   |\n| ---- | ------------------------------------------------------------ |\n| 1    | **布尔型** 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 |\n| 2    | **数字类型** 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 |\n| 3    | **字符串类型:** 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 |\n| 4    | **派生类型:** 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 |\n\n### 4. Go 语言变量\n\n变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。\n\nGo 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。\n\n声明变量的一般形式是使用 var 关键字 [ var  + 变量名 + 数据类型 ]：\n\n```go\nvar identifier type\n```\n\n#### 变量声明\n\n第一种，指定变量类型，声明后若不赋值，使用默认值。\n\n```\nvar v_name v_type\nv_name = value\n```\n\n第二种，根据值自行判定变量类型。\n\n```\nvar v_name = value\n```\n\n第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误,而且这种不带声明格式的 **只能在函数体中出现**。\n\n```\nv_name := value\n\n// 例如\nvar a int = 10\nvar b = 10\nc := 10\n\n```\n\n#### 多变量声明\n\n```go\n//类型相同多个变量, 非全局变量\nvar vname1, vname2, vname3 type\nvname1, vname2, vname3 = v1, v2, v3\n\nvar vname1, vname2, vname3 = v1, v2, v3 //和python很像,不需要显示声明类型，自动推断\n\n//这种不带声明格式的只能在函数体中出现\nvname1, vname2, vname3 := v1, v2, v3 //出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误\n\n// 这种因式分解关键字的写法一般用于声明全局变量\nvar (\n    vname1 v_type1\n    vname2 v_type2\n)\n\n```\n\n#### 值类型和引用类型\n\n所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值\n\n当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝\n\n可以通过 &i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。\n\n内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。\n\n更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。\n\n一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。\n\n这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。\n\n同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。\n\n当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。\n\n如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。\n\n#### 简短形式，使用 := 赋值操作符\n\n:= 是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。\n\n**全局变量是允许声明但不使用 **\n\n如果你想要交换两个变量的值，则可以简单地使用 **a, b = b, a**，两个变量的类型必须是相同。\n\n空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。\n\n_ 实际上是一个只写变量，你不能得到它的值。这样做是因为  **Go 语言中你必须使用所有被声明的变量**，但有时你并不需要使用从一个函数得到的所有返回值。\n\n### 5. Go 语言常量\n\n常量是一个简单值的标识符，在程序运行时，不会被修改的量。\n\n常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n\n常量的定义格式：\n\n```\nconst identifier [type] = value\n\n```\n\n你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型\n\n常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过\n\n**在定义常量组时，如果不提供初始值，则表示将使用上行的表达式。**\n\n#### iota 用法\n\niota 表示从 0 开始自动加 1\n\n```go\nconst (\n    a = iota\n    b\n    c\n)\n\n```\n\n**注意：**\n\n```\na = \"hello\"\nunsafe.Sizeof(a)\n\n```\n\n输出结果为：16\n\n字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。\n\n### 6. Go 语言运算符\n\n#### 指针运算符\n\n下表列出了Go语言的其他运算符。\n\n| 运算符 | 描述             | 实例                       |\n| ------ | ---------------- | -------------------------- |\n| &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |\n| *      | 指针变量。       | *a; 是一个指针变量         |\n\nGO 语言具有指针的概念\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var a int = 4\n   var ptr *int\n\n   /* 运算符实例 */\n   fmt.Printf(\"第 1 行 - a 变量类型为 = %T\\n\", a );\n\n   /*  & 和 * 运算符实例 */\n   ptr = &a    /* 'ptr' 包含了 'a' 变量的地址 */\n   fmt.Printf(\"a 的值为  %d\\n\", a);\n   fmt.Printf(\"*ptr 为 %d\\n\", *ptr);\n}\n\n```\n\n### 7.  Go 语言条件语句\n\n| 语句                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [if 语句](http://www.runoob.com/go/go-if-statement.html)     | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |\n| [if...else 语句](http://www.runoob.com/go/go-if-else-statement.html) | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |\n| [if 嵌套语句](http://www.runoob.com/go/go-nested-if-statements.html) | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |\n| [switch 语句](http://www.runoob.com/go/go-switch-statement.html) | **switch** 语句用于基于不同条件执行不同动作。                |\n| [select 语句](http://www.runoob.com/go/go-select-statement.html) | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |\n\n### 8. Go 语言循环语句\n\n#### 无限循环\n\n如过循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for true  {\n        fmt.Printf(\"这是无限循环。\\n\");\n    }\n}\n\n```\n\n### 9. Go 语言函数\n\nGo 语言最少有个 main() 函数。\n\n函数声明告诉了编译器函数的名称，返回类型，和参数。\n\n#### 函数定义\n\nGo 语言函数定义格式如下：\n\n```go\nfunc function_name( [parameter list] ) [return_types] {\n   函数体\n}\n\n```\n\n函数定义解析：\n\n- func：函数由 func 开始声明\n- function_name：函数名称，函数名和参数列表一起构成了函数签名。\n- parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。\n- return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。\n- 函数体：函数定义的代码集合。\n\n例子:\n\n```go\n/* 函数返回两个数的最大值 */\nfunc max(num1, num2 int) (int) {\n   /* 声明局部变量 */\n   var result int\n\n   if (num1 > num2) {\n      result = num1\n   } else {\n      result = num2\n   }\n   return result \n}\n\n```\n\n#### 函数返回多个值\n\nGo 函数可以返回多个值，例如：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n   return y, x\n}\n\nfunc main() {\n   a, b := swap(\"Mahesh\", \"Kumar\")\n   fmt.Println(a, b)\n}\n\n```\n\n#### 函数参数\n\n函数如果使用参数，该变量可称为函数的形参。\n\n形参就像定义在函数体内的局部变量。\n\n调用函数，可以通过两种方式来传递参数：\n\n| 传递类型                                                     | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [值传递](http://www.runoob.com/go/go-function-call-by-value.html) | 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |\n| [引用传递](http://www.runoob.com/go/go-function-call-by-reference.html) | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 |\n\n默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。\n\n#### Go 语言函数作为值\n\nGo 语言可以很灵活的创建函数，并作为值使用：\n\n```go\npackage main\n\nimport (\n   \"fmt\"\n   \"math\"\n)\n\nfunc main(){\n   /* 声明函数变量 */\n   getSquareRoot := func(x float64) float64 {\n      return math.Sqrt(x)\n   }\n\n   /* 使用函数 */\n   fmt.Println(getSquareRoot(9))\n\n}\n\n```\n\n#### Go 语言函数闭包\n\nGo 语言支持匿名函数，可作为闭包。匿名函数是一个\"内联\"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc getSequence() func() int {\n   i:=0\n   return func() int {\n      i+=1\n     return i  \n   }\n}\n\nfunc main(){\n   /* nextNumber 为一个函数，函数 i 为 0 */\n   nextNumber := getSequence()  \n\n   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   \n   /* 创建新的函数 nextNumber1，并查看结果 */\n   nextNumber1 := getSequence()  \n   fmt.Println(nextNumber1())\n   fmt.Println(nextNumber1())\n}\n\n```\n\n由于闭包返回的是一个函数的结果，故在声明函数时，也必须声明返回结果为函数的结果\n\n```go\nfunc getSequence() func() int {                 //声明返回结果为函数的结果\n   i:=0\n   return func() int {                          //返回的是一个函数的结果\n      i+=1\n     return i  \n   }\n}\n\n```\n\n#### Go 语言函数方法\n\nGo 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：\n\n```go\nfunc (variable_name variable_data_type) function_name() [return_type]{\n   /* 函数体*/\n}\n\n```\n\n```go\npackage main\n\nimport (\n   \"fmt\"  \n)\n\n/* 定义结构体 */\ntype Circle struct {\n  radius float64\n}\n\nfunc main() {\n  var c1 Circle\n  c1.radius = 10.00\n  fmt.Println(\"圆的面积 = \", c1.getArea())\n}\n\n//该 method 属于 Circle 类型对象中的方法\nfunc (c Circle) getArea() float64 {\n  //c.radius 即为 Circle 类型对象中的属性\n  return 3.14 * c.radius * c.radius\n}\n\n```\n\n### 10.Go 语言变量作用域\n\n作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。\n\nGo 语言中变量可以在三个地方声明：\n\n- 函数内定义的变量称为局部变量\n- 函数外定义的变量称为全局变量\n- 函数定义中的变量称为形式参数\n\nGo 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑\n\n### 11.Go 语言数组\n\n#### 声明数组\n\nGo 语言数组声明需要指定元素类型及元素个数，语法格式如下：\n\n```\nvar variable_name [SIZE]variable_type\n\n```\n\n以上为一维数组的定义方式。例如以下定义了数组 balance 长度为 10 类型为 float32：\n\n```\nvar balance [10]float32\n\n```\n\n#### 初始化数组\n\n以下演示了数组初始化：\n\n```\nvar balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}\n\n```\n\n初始化数组中 {} 中的元素个数不能大于 [] 中的数字。\n\n如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：\n\n```\n var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}\n\n```\n\n该实例与上面的实例是一样的，虽然没有设置数组的大小。\n\n```\n balance[4] = 50.0\n\n```\n\n以上实例读取了第五个元素。数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。\n\n#### 初始化二维数组\n\n多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：\n\n```go\na = [3][4]int{  \n {0, 1, 2, 3} ,   /*  第一行索引为 0 */\n {4, 5, 6, 7} ,   /*  第二行索引为 1 */\n {8, 9, 10, 11},   /* 第三行索引为 2 */\n}\n\n```\n\n> 注意：\n>\n> 以上代码中倒数第二行的 } 必须要有逗号，因为最后一行的 }不能单独一行，也可以写成这样：\n>\n> ```\n> a = [3][4]int{  \n>  {0, 1, 2, 3} ,   /*  第一行索引为 0 */\n>  {4, 5, 6, 7} ,   /*  第二行索引为 1 */\n>  {8, 9, 10, 11}}   /* 第三行索引为 2 */\n> \n> ```\n\n#### Go 语言向函数传递数组\n\n如果想向函数传递数组参数,需要在函数定义时，声明形参为数组\n\n1.形参设定数组大小：\n\n```\nvoid myFunction(param [10]int)\n{\n...\n}\n\n```\n\n2.形参未设定数组大小：\n\n```\nvoid myFunction(param []int)\n{\n...\n}\n\n```\n\n### 12.Go 语言指针\n\nGo 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。\n\n#### 什么是指针\n\n一个指针变量指向了一个值的内存地址。\n\n类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：\n\n```\nvar var_name *var-type\n\n```\n\nvar-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：\n\n```\nvar ip *int        /* 指向整型*/\nvar fp *float32    /* 指向浮点型 */\n\n```\n\n#### Go 空指针\n\n当一个指针被定义后没有分配到任何变量时，它的值为 nil。\n\nnil 指针也称为空指针。\n\nnil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。\n\n一个指针变量通常缩写为 ptr\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var  ptr *int\n\n   fmt.Printf(\"ptr 的值为 : %x\\n\", ptr  )\n}  \n\n结果 ： ptr 的值为 : 0\n\n```\n\n空指针判断：\n\n```\nif(ptr != nil)     /* ptr 不是空指针 */\nif(ptr == nil)     /* ptr 是空指针 */\n\n```\n\n#### Go 语言指针数组\n\n以下声明了整型指针数组：\n\n```\nvar ptr [MAX]*int;\n\n```\n\nptr 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：\n\n```go\npackage main\n\nimport \"fmt\"\n\nconst MAX int = 3\n\nfunc main() {\n   a := []int{10,100,200}\n   var i int\n   var ptr [MAX]*int;\n\n   for  i = 0; i < MAX; i++ {\n      ptr[i] = &a[i] /* 整数地址赋值给指针数组 */\n   }\n\n   for  i = 0; i < MAX; i++ {\n      fmt.Printf(\"a[%d] = %d\\n\", i,*ptr[i] )\n   }\n}\n\n```\n\n#### Go 语言指向指针的指针\n\n如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。\n\n当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：\n\n![](http://www.runoob.com/wp-content/uploads/2015/06/pointer_to_pointer.jpg)\n\n\n\n指向指针的指针变量声明格式如下：\n\n```\nvar ptr **int;\n\n```\n\n以上指向指针的指针变量为整型。\n\n访问指向指针的指针变量值需要使用两个 * 号，如下所示：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\n   var a int\n   var ptr *int\n   var pptr **int\n\n   a = 3000\n\n   /* 指针 ptr 地址 */\n   ptr = &a\n\n   /* 指向指针 ptr 地址 */\n   pptr = &ptr\n\n   /* 获取 pptr 的值 */\n   fmt.Printf(\"变量 a = %d\\n\", a )\n   fmt.Printf(\"指针变量 *ptr = %d\\n\", *ptr )\n   fmt.Printf(\"指向指针的指针变量 **pptr = %d\\n\", **pptr)\n}\n\n```\n\n#### Go 语言指针作为函数参数\n\nGo 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。\n\n以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值 [即：不改变指针指向的情况下，改变变量的值]:\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   /* 定义局部变量 */\n   var a int = 100\n   var b int= 200\n\n   fmt.Printf(\"交换前 a 的值 : %d\\n\", a )\n   fmt.Printf(\"交换前 b 的值 : %d\\n\", b )\n\n   /* 调用函数用于交换值\n   * &a 指向 a 变量的地址\n   * &b 指向 b 变量的地址\n   */\n   swap(&a, &b);\n\n   fmt.Printf(\"交换后 a 的值 : %d\\n\", a )\n   fmt.Printf(\"交换后 b 的值 : %d\\n\", b )\n}\n\nfunc swap(x *int, y *int) {\n   // *x, *y = *y, *x\n   var temp int\n   temp = *x    /* 保存 x 地址的值 */\n   *x = *y      /* 将 y 赋值给 x */\n   *y = temp    /* 将 temp 赋值给 y */\n}\n\n```\n\n### 13. Go 语言结构体\n\n#### 定义结构体\n\n结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体有中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：\n\n**注意：**在结构体定义中，可以省略 var 关键字\n\n```go\ntype struct_variable_type struct {\n   member definition;\n   member definition;\n   ...\n   member definition;\n}\n\n```\n\n一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：\n\n```go\nvariable_name := structure_variable_type {value1, value2...valuen}\n或\nvariable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}\n\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Books struct {\n   title string\n   author string\n   subject string\n   book_id int\n}\n\nfunc main() {\n    \n    // 创建一个新的结构体\n    fmt.Println(Books{\"Go 语言\", \"www.runoob.com\", \"Go 语言教程\", 6495407})\n\n    // 忽略的字段为 0 或 空\n   fmt.Println(Books{title: \"Go 语言\", author: \"www.runoob.com\"})\n}\n\n```\n\n#### 访问结构体成员\n\n如果要访问结构体成员，需要使用点号 **.** 操作符，格式为：\n\n```\n结构体.成员名\"\n\n```\n\n结构体类型变量使用 struct 关键字定义\n\n#### 结构体作为函数参数\n\n可以像其他数据类型一样将结构体类型作为参数传递给函数\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Books struct {\n   title string\n   author string\n   subject string\n   book_id int\n}\n\nfunc main() {\n   var Book1 Books        /* 声明 Book1 为 Books 类型 */\n   \n   /* book 1 描述 */\n   Book1 = Books{\"Go 语言\", \"www.runoob.com\", \"Go 语言教程\", 6495407}\n   \n   /* 打印 Book1 信息 */\n   printBook(Book1)\n\n}\n\nfunc printBook( book Books ) {\n   fmt.Printf( \"Book title : %s\\n\", book.title);\n   fmt.Printf( \"Book author : %s\\n\", book.author);\n   fmt.Printf( \"Book subject : %s\\n\", book.subject);\n   fmt.Printf( \"Book book_id : %d\\n\", book.book_id);\n}\n\n```\n\n#### 结构体指针\n\n可以定义指向结构体的指针类似于其他指针变量，格式如下：\n\n```\nvar struct_pointer *Books\n\n```\n\n以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 & 符号放置于结构体变量前：\n\n```\nstruct_pointer = &Book1;\n\n```\n\n使用结构体指针访问结构体成员，使用 \".\" 操作符：\n\n```\nstruct_pointer.title;\n\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Books struct {\n   title string\n   author string\n   subject string\n   book_id int\n}\n\nfunc main() {\n\n   /* book 1 描述 */\n   Book1 := Books{\"Go 语言\", \"www.runoob.com\", \"Go 语言教程\", 6495407}\n   \n   /* 打印 Book1 信息 */\n   printBook(&Book1)\n\n}\nfunc printBook( book *Books ) {\n   fmt.Printf( \"Book title : %s\\n\", book.title);\n   fmt.Printf( \"Book author : %s\\n\", book.author);\n   fmt.Printf( \"Book subject : %s\\n\", book.subject);\n   fmt.Printf( \"Book book_id : %d\\n\", book.book_id);\n}\n\n```\n\n**注意**：在访问结构体成员时，无论使用结构体指针访问，还是结构体访问，访问的方式均为 **结构体.结构体变量**\n\n### 14. Go 语言切片(Slice)\n\nGo 语言切片是对数组的抽象。\n\nGo 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\"),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大\n\n#### 定义切片\n\n你可以声明一个未指定大小的数组来定义切片：\n\n```\nvar identifier []type\n\n```\n\n**切片不需要说明长度**。\n\n或使用make()函数来创建切片:\n\n```\nvar slice1 []type = make([]type, len)\n\n也可以简写为\n\nslice1 := make([]type, len)\n\n```\n\n也可以指定容量，其中capacity为可选参数。\n\n```\nmake([]T, length, capacity)\n\n```\n\n这里 len 是数组的长度并且也是切片的初始长度。\n\n#### 切片初始化\n\n```\ns :=[] int {1,2,3} \n\n```\n\n直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3\n\n```\ns := arr[:] \n\n```\n\n初始化切片s,是数组arr的引用\n\n```\ns := arr[startIndex:endIndex] \n\n```\n\n将arr中从下标 startIndex 到 **endIndex-1** 下的元素创建为一个新的切片\n\n```\ns := arr[startIndex:] \n\n```\n\n缺省endIndex时将表示一直到arr的最后一个元素\n\n```\ns := arr[:endIndex] \n\n```\n\n缺省startIndex时将表示从arr的第一个元素开始\n\n```\ns1 := s[startIndex:endIndex] \n\n```\n\n通过切片s初始化切片s1\n\n```\ns :=make([]int,len,cap) \n\n```\n\n通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片\n\n#### len() 和 cap() 函数\n\n切片是可索引的，并且可以由 len() 方法获取长度。\n\n切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。\n\n**而 cap() 的值，切片每增加一个 int 型数据，空间值增长 2 **\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var numbers = make([]int,3,5)\n\n   printSlice(numbers)\n}\n\nfunc printSlice(x []int){\n   fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\n}\n\n结果 ： len=3 cap=5 slice=[0 0 0]\n\n```\n\n#### 空(nil)切片\n\n一个切片在未初始化之前默认为 nil，长度为 0，实例如下：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var numbers []int\n\n   printSlice(numbers)\n\n   if(numbers == nil){\n      fmt.Printf(\"切片是空的\")\n   }\n}\n\nfunc printSlice(x []int){\n   fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\n}\n\n```\n\n#### 切片截取\n\n可以通过设置下限及上限来设置截取切片 *[lower-bound:upper-bound]*\n\n#### append() 和 copy() 函数\n\n如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。\n\n下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   var numbers []int\n   printSlice(numbers)\n\n   /* 允许追加空切片 */\n   numbers = append(numbers, 0)\n   printSlice(numbers)\n\n   /* 同时添加多个元素 */\n   numbers = append(numbers, 1,2,3,4)\n   printSlice(numbers)\n\n   /* 创建切片 numbers1 是之前切片的两倍容量*/\n   numbers1 := make([]int, len(numbers), (cap(numbers))*2)\n\n   /* 拷贝 numbers 的内容到 numbers1 */\n   copy(numbers1,numbers)\n   printSlice(numbers1)   \n}\n\nfunc printSlice(x []int){\n   fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)\n}\n\n```\n\n### 15. Go 语言范围(Range)\n\nGo 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对的 key 值。\n\n```go\npackage main\nimport \"fmt\"\nfunc main() {\n    //这是我们使用range去求一个slice的和。使用数组跟这个很类似\n    nums := []int{2, 3, 4}\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    fmt.Println(\"sum:\", sum)\n    //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符\"_\"省略了。有时侯我们确实需要知道它的索引。\n    for i, num := range nums {\n        if num == 3 {\n            fmt.Println(\"index:\", i)\n        }\n    }\n    //range也可以用在map的键值对上。\n    kvs := map[string]string{\"a\": \"apple\", \"b\": \"banana\"}\n    for k, v := range kvs {\n        fmt.Printf(\"%s -> %s\\n\", k, v)\n    }\n    //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。\n    for i, c := range \"go\" {\n        fmt.Println(i, c)\n    }\n}\n\n```\n\n### 16.Go 语言Map(集合)\n\nMap 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。\n\nMap 是一种集合，所以我们可以像迭代数组和切片那样迭代它。\n\n注意点：**Map 是无序的，我们无法决定它的返回顺序**，这是因为 Map 是使用 hash 表来实现的。\n\n#### 定义 Map\n\n可以使用内建函数 make 也可以使用 map 关键字来定义 Map:\n\n```\n/* 声明变量，默认 map 是 nil */\nvar map_variable map[key_data_type]value_data_type\n\n/* 使用 make 函数,初始化map */\nmap_variable := make(map[key_data_type]value_data_type)\n\n```\n\n如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    /*创建集合 */\n    var countryCapitalMap map[string]string \n    \n    /* 如果不适用 make 函数初始化，将会报错*/\n    countryCapitalMap = make(map[string]string)\n\n    /* map插入key - value对,各个国家对应的首都 */\n    countryCapitalMap [ \"France\" ] = \"Paris\"\n    countryCapitalMap [ \"Italy\" ] = \"罗马\"\n    countryCapitalMap [ \"Japan\" ] = \"东京\"\n    countryCapitalMap [ \"India \" ] = \"新德里\"\n\n    /*使用键输出地图值 */ \n    for country := range countryCapitalMap {\n        fmt.Println(country, \"首都是\", countryCapitalMap [country])\n    }\n    \n    /*如果使用以下方法\n    for country,v := range countryCapitalMap {\n      fmt.Println(country, \"首都是\", v)\n    则输出的结果将会是无序的。\n    */\n\n    /*查看元素在集合中是否存在 */\n    captial, ok := countryCapitalMap [ \"美国\" ]\n    /*如果确定是真实的,则存在,否则不存在 */\n    if (ok) {\n        fmt.Println(\"美国的首都是\", captial)\n    } else {\n        fmt.Println(\"美国的首都不存在\")\n    }\n}\n\n```\n\n#### delete() 函数\n\ndelete() 函数用于删除集合的元素, 参数为 map 和其对应的 key\n\n```go\ncountryCapitalMap := map[string]string{\"France\": \"Paris\", \"Italy\": \"Rome\", \"Japan\": \"Tokyo\", \"India\": \"New delhi\"}\n\n/*删除元素*/\ndelete(countryCapitalMap, \"France\")\nfmt.Println(\"法国条目被删除\")\n\n```\n\n### 17. Go 语言递归函数\n\n递归，就是在运行的过程中调用自己。\n\n语法格式如下：\n\n```go\nfunc recursion() {\n   recursion() /* 函数调用自身 */\n}\n\nfunc main() {\n   recursion()\n}\n\n```\n\n#### 阶乘\n\n以下实例通过 Go 语言的递归函数实例阶乘：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc Factorial(n uint64)(uint64) {\n    if (n > 0) {\n        result := n * Factorial(n-1)\n        return result\n    }\n    return 1\n}\n\nfunc main() {  \n    var i int = 15\n    fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i)))\n}\n\n```\n\n#### 斐波那契数列\n\n以下实例通过 Go 语言的递归函数实现斐波那契数列：\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n  if n < 2 {\n   return n\n  }\n  return fibonacci(n-2) + fibonacci(n-1)\n}\n\nfunc main() {\n    var i int\n    for i = 0; i < 10; i++ {\n       fmt.Printf(\"%d\\t\", fibonacci(i))\n    }\n}\n\n```\n\n### 18. Go 语言类型转换\n\n类型转换用于将一种数据类型的变量转换为另外一种类型的变量, Go 语言类型转换基本格式如下：\n\n```\ntype_name(expression)\n\n```\n\ntype_name 为类型，expression 为表达式。\n\n### 19. Go 语言接口\n\nGo 语言提供了一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Phone interface {\n    call()\n}\n\ntype NokiaPhone struct {\n}\n\nfunc (nokiaPhone NokiaPhone) call() {\n    fmt.Println(\"I am Nokia, I can call you!\")\n}\n\ntype IPhone struct {\n}\n\nfunc (iPhone IPhone) call() {\n    fmt.Println(\"I am iPhone, I can call you!\")\n}\n\nfunc main() {\n    var phone Phone\n\n    nokiaPhone := NokiaPhone{}\n    nokiaPhone.call()\n    \n    phone = new(NokiaPhone)\n    phone.call()\n\n    phone = new(IPhone)\n    phone.call()\n\n}\n\n```\n\n在上面的例子中，我们定义了一个接口 Phone，接口里面有一个方法 call()。然后我们在 main 函数里面定义了一个Phone 类型变量，并分别为之赋值为 NokiaPhone 和 IPhone。然后调用 call() 方法\n\n### 20. Go 错误处理\n\nGo 语言通过内置的错误接口提供了非常简单的错误处理机制。\n\nerror类型是一个接口类型，这是它的定义：\n\n```go\ntype error interface {\n    Error() string\n}\n\n```\n\n我们可以在编码中通过实现 error 接口类型来生成错误信息。\n\n函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：\n\n```go\nfunc Sqrt(f float64) (float64, error) {\n    if f < 0 {\n        return 0, errors.New(\"math: square root of negative number\")\n    }\n    // 实现\n}\n\n```\n\npanic 与 recover,一个用于主动抛出错误，一个用于捕获panic抛出的错误。\n\n**概念**\n\npanic 与 recover 是 Go 的两个内置函数，这两个内置函数用于处理 Go 运行时的错误，panic 用于主动抛出错误，recover 用来捕获 panic 抛出的错误。\n\n- 引发`panic`有两种情况，一是程序主动调用，二是程序产生运行时错误，由运行时检测并退出。\n- 发生`panic`后，程序会从调用`panic`的函数位置或发生`panic`的地方立即返回，逐层向上执行函数的`defer`语句，然后逐层打印函数调用堆栈，直到被`recover`捕获或运行到最外层函数。\n- `panic`不但可以在函数正常流程中抛出，在`defer`逻辑里也可以再次调用`panic`或抛出`panic`。`defer`里面的`panic`能够被后续执行的`defer`捕获。\n- `recover`用来捕获`panic`，阻止`panic`继续向上传递。`recover()`和`defer`一起使用，但是`defer`只有在后面的函数体内直接被掉用才能捕获`panic`来终止异常，否则返回`nil`，异常继续向外传递。**此句不是很理解**\n\n多个panic只会捕捉最后一个：\n\n```go\npackage main\nimport \"fmt\"\nfunc main(){\n    defer func(){\n        err := recover() \n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n    defer func(){\n        panic(\"three\")\n    }()\n    defer func(){\n        panic(\"two\")\n    }()\n    panic(\"one\")\n}\n\n```\n\n**使用场景**\n\n一般情况下有两种情况用到：\n\n-  程序遇到无法执行下去的错误时，抛出错误，主动结束运行。\n-  在调试程序时，通过 panic 来打印堆栈，方便定位错误。\n\n### 21. Go 并发\n\nGo 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。\n\ngoroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。\n\ngoroutine 语法格式：\n\n```\ngo 函数名( 参数列表 )\n\n```\n\nGo 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。**同一个程序中的所有 goroutine 共享同一个地址空间**。\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n        \"time\"\n)\n\nfunc say(s string) {\n        for i := 0; i < 5; i++ {\n                time.Sleep(100 * time.Millisecond)\n                fmt.Println(s)\n        }\n}\n\nfunc main() {\n        go say(\"world\")\n        say(\"hello\")\n}\n\n```\n\n#### 通道（channel）\n\n通道（channel）是用来传递数据的一个数据结构。\n\n通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 `<-` 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。\n\n```go\nch <- v    // 把 v 发送到通道 ch\nv := <-ch  // 从 ch 接收数据\n           // 并把值赋给 v\n\n```\n\n声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：\n\n```go\nch := make(chan int)\n\n```\n\n**注意**：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须又接收端相应的接收数据。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n        sum := 0\n        for _, v := range s {\n                sum += v\n        }\n        c <- sum // 把 sum 发送到通道 c\n}\n\nfunc main() {\n        s := []int{7, 2, 8, -9, 4, 0}\n\n        c := make(chan int)\n        go sum(s[:len(s)/2], c)\n        go sum(s[len(s)/2:], c)\n        x, y := <-c, <-c // 从通道 c 中接收\n\n        fmt.Println(x, y, x+y)\n}\n\n结果： -5 17 12\n\n```\n\n#### 通道缓冲区\n\n通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：\n\n```\nch := make(chan int, 100)\n\n```\n\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n\n不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。\n\n**注意**：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // 这里我们定义了一个可以存储整数类型的带缓冲通道\n        // 缓冲区大小为2\n        ch := make(chan int, 2)\n\n        // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据\n        // 而不用立刻需要去同步读取数据\n        ch <- 1\n        ch <- 2\n\n        // 获取这两个数据\n        fmt.Println(<-ch)\n        fmt.Println(<-ch)\n}\n\n```\n\n#### Go 遍历通道与关闭通道\n\nGo 通过 range 关键字来实现遍历读取道的数据，类似于与数组或切片。格式如下：\n\n```go\nv, ok := <-ch\n\n```\n\n如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 **close()** 函数来关闭。\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n        x, y := 0, 1\n        for i := 0; i < n; i++ {\n                c <- x\n                x, y = y, x+y\n        }\n        close(c)\n}\n\nfunc main() {\n        c := make(chan int, 10)\n        go fibonacci(cap(c), c)\n        /* range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个\n         数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据\n         之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不\n         会结束，从而在接收第 11 个数据的时候就阻塞了。*/\n        for i := range c {\n                fmt.Println(i)\n        }\n}\n\n```\n\ngoroutine 是 golang 中在语言级别实现的轻量级线程，仅仅利用 go 就能立刻起一个新线程。多线程会引入线程之间的同步问题，在 golang 中可以使用 channel 作为同步的工具。\n\n通过 channel 可以实现两个 goroutine 之间的通信。\n\n创建一个 channel， make(chan TYPE {, NUM}) TYPE 指的是 channel 中传输的数据类型，第二个参数是可选的，指的是 channel 的容量大小。\n\n向 channel 传入数据， CHAN <- DATA ， CHAN 指的是目的 channel 即收集数据的一方， DATA 则是要传的数据。\n\n从 channel 读取数据， DATA := <-CHAN ，和向 channel 传入数据相反，在数据输送箭头的右侧的是 channel，形象地展现了数据从隧道流出到变量里。\n\n我们单独写一个 say2 函数来跑 goroutine，并且 Sleep 时间设置为150 毫秒，比主函数暂停时间长：\n\n```go\npackage main\nimport (\n    \"fmt\"\n    \"time\"\n)\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s, (i+1)*100)\n    }\n}\nfunc say2(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(150 * time.Millisecond)\n        fmt.Println(s, (i+1)*150)\n    }\n}\nfunc main() {\n    go say2(\"world\")\n    say(\"hello\")\n}\n\n结果：\nhello 100\nworld 150\nhello 200\nhello 300\nworld 300\nhello 400\nworld 450\nhello 500\n\n```\n\n问题来了，say2 只执行了 3 次，而不是设想的 5 次\n\n因为 goroutine 还没来得及跑完 5 次的时候，主函数已经退出了。\n\n阻止主函数的结束，要等待 goroutine 执行完成之后，再退出主函数：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s, (i+1)*100)\n    }\n}\nfunc say2(s string, ch chan int) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(150 * time.Millisecond)\n        fmt.Println(s, (i+1)*150)\n    }\n    ch <- 0\n    close(ch)\n}\n\nfunc main() {\n    ch := make(chan int)\n    go say2(\"world\", ch)\n    say(\"hello\")\n    fmt.Println(<-ch)\n}\n\n```\n\n引入一个信道，默认的，信道的存消息和取消息都是阻塞的，在 goroutine 中执行完成后给信道一个值 0，则主函数会一直等待信道中的值，一旦信道有值，主函数才会结束。\n","tags":["go"]},{"title":"Hello World","url":"/2019/02/18/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"},{"title":"session与cookie学习心得","url":"/2018/01/04/session与cookie学习心得/","content":"## session 和 cookie\n\n### cookie\n\ncookie 是存储在客户端上的一小段数据，浏览器通过HTTP协议和服务器进行cookie交换。\n\n```\n注:能管理 cookie 不仅仅是浏览器\n```\n\ncookie 独立与语言存在，但很多语言都有实现 cookie [ 其实：间接操作（发生 HTTP 指令）]，因此 cookie 是由浏览器实现和管理的\n\n例：PHP 可以设置 cookie，但实际上 PHP 并没有实际的设置过 cookie，可以说PHP没有能力设置 cookie ，PHP 只是发出命令让浏览器来做这件事情\n\n```\n注：1. 以 PHP 为例，如果 PHP 在当前页面设置的 cookie 不能立即生效，要等到下一个页面才能看到，但若是 javascript 设置，时立即生效到。\n   \n    2. cookie 没有显示删除，若想删除，只能将过期时间设置为以前的时间\n```\n\ncookie 一般存放不敏感信息，而且 cookie 的数量不是越多越好，它会增加带宽。\n\n```\n注:不要把 cookie 当作本地存储器 \n```\n\ncookie 一般会保存到两种地方：1.文件中 2.浏览器内存中\n\n```\n注：关闭浏览器 cookie 不会失效，除非超时时间设置为空\n```\n\n正常的 cookie 只能在一个应用中共享（即：一个 cookie 只能由创建他的应用获得），但为了实现 cookie 的跨域使用，最好的方式就是用 P3P 协议\n\n一个域名的每个 cookie 限制以 4 千字节的键值对的形式存在，若是服务端也使用的话，cookie 的存储大小就可能不够用，于是出现一个新的解决方案：localstorage。[在这里我就不详述了]\n\n### session\n\nsession 即会话，一种持续性的、双向性的连接\n\n```\n注：session 和 cookie 都是客户端与服务器间保持会话连接状态的机制\n```\n\nsession 的实现方式：URL 重写、cookie、通过在 cookie 中存储的 sessionID 实现 session 传递 \n\nsession 指用户进入网站到浏览器关闭这段时间内的会话。[特定的时间概念]\n\n以 PHP 为例：session 默认以文件方式实现，存储在服务器的 session 文件，每个 session 一个文件\n\nsession 是通过 sessionID 判断客户端用户的，即：session 文件的文件名\n\nsessionID 必须包含在 HTTPRequest 里面，保证唯一性和随机性。\n\n没有设置 session 的生命周期，sessionID 存储在内存中，关闭浏览器后 ID 自动注销，若设置生命周期，session 过期后，才会回收。session 并不是都随浏览器关闭而关闭。\n\n```\n注：对于设置分级目录存储的 session ，PHP 不会自动回收。\n```\n\n### 易错点\n\n1. cookie 运行在客户端 session 运行在服务器端对吗？\n\n   答：不完全正确，因为 sessionID 作为 cookie 存储在客户端\n\n2. 浏览器禁用 cookie，cookie 不能用了,session 会受到影响吗？\n\n   答：session 会受到影响，但可以通过 URL 传递 session\n\n3. session 比 cookie 更安全吗？\n\n   答：cookie 和 session 是绑定的，获得 cookie 就相当获得了 session，客户端吧劫持的 cookie 原封不动地传给服务器，服务器收到后，原封不动的验证session，若 session 存在，就实现了 cookie 和 session 的绑定过程。因此，不存在 session 比cookie 更安全的说法。\n\n4. 如果把别人机器上的 cookie 文件复制到我的电脑上，是不是可以登陆别人账号。\n\n   答：可以，这样的操作属于 cookie 劫持，要避免这种情况，需要在 cookie 中针对 IP、UA 等加上特殊的校验信息，然后再和服务器对比。\n\n\n","tags":["NET"]},{"title":"TCP连接详解","url":"/2018/01/03/TCP连接详解/","content":"## 学习TCP有感\n\n### 前言\n\n小宝最近看了一本名叫 《wireshark 网络分析就是这么简单》 的书，该书使用 wireshark 抓取网络包，分析每个包的含义，从而更直观的理解协议的本质。小宝大约花了4天的时间，看完此书，自己感悟最大的地方就是 TCP 协议部分，所以就不废话了，直接上感悟\n\n#### TCP 连接\n\n这里小宝就不对 TCP 的定义做介绍了，大家可以自行 google ，但大家要知道 TCP 是有保障（即:建立连接)的传输层协议。\n\n1. #### 建立连接：\n\n   建立连接时，需要经过三次握手\n\n   ![三次握手](http://n1.cmsfile.pg0.cn/group1/M00/1A/7E/Cgqg2FZAQK-AKig6AAB4dr6gkoY992.jpg) \n\n   由上图可知：\n\n   TCP 的第一次握手是由客户端向服务器发送的 标志位为 SYN=1（连接标志位） seq=J（数据段序号） len=0（携带报文个数）\n   \t\n   TCP 的第二次握手是由服务器向客户端发送的 标志位为 SYN=1 ACK=1（确认标识位） seq=K ack=J+1 len=0 \n\n   TCP 的第三次握手是由客户端向服务器发送的 标志位为 ACK=1 seq=J+1 ack=k+1 len=0\n\n   白话解释：\n\n   第一次：客户端;我能和你连接吗？我的初始序号是 J，如果你应答就 ack=J+1\n\n   第二次：服务端：收到了，ack=J+1,我也想和你建立连接，我的初始序号是 K,如果你答应就 ack =K+1\n\n   第三次：客户端：收到了，ack =k+1\n\n   注意:SYN 包，虽然 len =0但是会消耗一个序号，但 ACK 包，如果 len=0,则不会消耗序号（即:可以使用同一个包重复确认）\n\n2. #### 传输过程：\n\n   传输数据，对于 TCP 在传输数据这部分，小宝主要要讲 MTU（最大传输单元）、Win（发送窗口）、超时重传、快速恢复等\n\n   1.MTU（最大传输单元）[1500字节] = MSS(TCP 包所携带的最大数据量)[一般为1460字节]+ TCP 报文头[20字节] + TP 报文头[20字节]\n\n     MSS决定发送方要讲一个大数据包要被分成多少个 TCP 分组，再进行发送\n\n   2.滑动窗口机制\n\n    当用 wireshark 进行抓包时，包中的 WIN 的值不是指源地址发送窗口的大小，而是源地址向目的地址声明自己的接收窗口的大小，\n\n    当目的地址接收到该信息后，会将自己的发送窗口大小设定小于源地址的接收窗口的大小，（即：接收方的接收窗口大小决定发送方的发送窗口大小)\n\n    Win（发送窗口）决定了发送方一口气能发多少字节\n   \t\n   `附: 由于 TCP 刚被发发明是全世界网络都很小，所以最大接收窗口被定义为 65535 字节，但由于硬件的革命性进步，65535字节已成为瓶颈，`\n\n   ` 而TCP 头只给接收窗口值留了 16 bit，故依靠 TCP 头肯定无法突破 65535，1992 年的 RFC 1323 中体提出的 Window Scale，Window Scale `\n\n   ` 放在TCP 头之外的 Options 中。不需要改变 TCP 头的设计，Window Scale 是在 TCP 的三次握手阶段，向对方声明一个 Shift count,然后将 `\n\n   ` Shift count 作为2的指数，在乘以 TCP 中第一的接受窗口，就可以得到真正的窗口（即：wireshark 包中 Calculated window size 的值）`\n\n   ` 注意：有时候防火墙识别不了 Window Scale ，无法获得 Shift count，会导致接收方接收窗口过小，从而发送方的发送方发生窗口过小，造成 `\n\n    ` 严重性能问题 `\n\n   3.超时重传\n\n   刚刚建立连接时，发送方不知道网络的状况，RFC 建议每收到 n 个确认就将用拥塞窗口加 n 个MSS，此过程称为慢启动阶段，公式 y=2^x (x>0)\n\n   当慢启动持续一段时间后。当拥塞窗口值达到临界窗口值时，退出慢启动阶段，RFC 建议每一个RTT（往返时间）拥塞窗口值增加 1，此过程称为拥塞避免阶段\n\n   当在一个RTO(超时时间)未收到特定包，说明发生拥塞，特定包已丢失，于是进行超时重传\n\n   注意:超时重传对传输性能有很严重的影响，原因：1.在 RTO 阶段不能传数据，2.在拥塞窗口急剧减小（这里你可以认为是发送窗口），以后传输很慢\n\n   超时重传阶段，RFC 建议将拥塞窗口的值降到 1个 MSS，临界窗口定义为上次发生拥塞时发生窗口的一半，然后再次进入慢启动。[注意:临界窗口有分歧\n   ]\n\n   ` 在《TCP/IP Illustrated》一书（此书发布与1999年以前）中临界窗口定义为上次发生拥塞时发生窗口的一半，而RFC 2581 参考了 Westwood+ 算法，将原先“拥塞窗口的一半”改为 FlightSize（已发送单位确认的数据量）的一半。（很可惜，现实与理想的差距很大，RFC 2581 并未像 Westwood+ 一样追\n   求比较理想的窗口，而且还造成一个很大的问题了[即：小带宽网络丢包多，大带宽网络丢包少，但大带宽网络的临界窗口却小于小带宽网络]）`\n\n   4.快速恢复\n\n   当网络出现轻微的阻塞时，少量数据包丢失，（即：存在包丢失，但后续的包仍能正常到达接收方），只不过接受方发现seq号比预期的大，所以接收方收到第一个seq号比预期的包时，它会ack一次期望的seq号（注意：这个包是ACK包），之后每收到一个包就ack一次期望的seq号（注意：这些包是Dup ACK包）,当发送发收到3个或3个以上的重复确认（Dup ACK包）【一定要注意这里是收到3个重复确认，不是收到3个ack（1个 ACK 和2个 Dup ACK）】,发送方意识到相应的包已丢失，从而立即重传他，该过程称为快速重传。\n\n   这是这部分很重要的点哦，《TCP/IP Illustrated》一书中认为临界窗口定义为上次发生拥塞时发生窗口的一半，拥塞窗口也定义为上次发生拥塞时发生窗口的一半，接着进入拥塞避免阶段；而 RFC 5681 认为临界窗口定义为发生拥塞时还未被确认的数据量的一半（但不能小于2），然后拥塞窗口值定义为临界窗口指加上 3 个 MSS，接着进入拥塞避免阶段。\n\n   既然要快速恢复，怎么才能快速呢？这必然要经历进化嘛。\n\n   1.最初阶段：丢一个包，该包和之后的包都重传[我的天，这得花多少冤枉的资源啊]\n\n   2.NewReno 方案：丢失一个包，接收方接到重传的该包时，回复下一个对丢失报的序号，然后发送方在重传，直至把丢失的包都补上[听起来比最初靠谱多了，可仔细想想，要是丢包量很大，那要花费对少个RTT（往返时间）啊]\n\n   3.SACK 方案：（小宝现在学到的最好的恢复方法）接收方在请求丢失包的同时把收到的包号告诉发送方\n\n   注意：是否启用 SACK实在 TCP 三次握手时协商决定的，只要双方一方没有发“SACK_PERM=1”,那该连接建立之后就不会用到 SACK\n   \t  \n\n   ```\n   让终端运行 SACK 的 命令： ` no -p -o sack=1 `\n   ```\n\n   为什么规定要凑满3个 Dup ACK 呢？\n\n   是不是笨，因为网路包他本来就不安分，有时自己就会乱序，但因为乱序就重传的话，那我们岂不是它谨慎了（好浪费资源的），而且 Don't worry,\n   一般乱序的距离不会相差太大（说白了，就是不满足3个 Dup ACK）\n\n   5.延时确认\n\n   只是减少本部分确认包，减轻网络负担，并没有直接提高性能，有时候反而会影响性能\t\n\n   6.Nagle 算法[缓冲机制,作用是将一个往返时间里生成的小数据收集起来，凑满一个 MSS 或者等收到确认后在发送]\n\n   没有直接提高性能,启用它的作用只是提高传输效率，减轻网络负担，但某些场合也会影响性能，但很多软件默认关闭 Nagle \n\n3. #### 断开连接\n\n   ![四次挥手](http://static.open-open.com/lib/uploadImg/20160919/20160919153347_419.jpg)          \n\n   由上图可知：（连接的示意图如图，ack 等的数据是小宝自己编的，与图中不一样，请见谅）\n\n   TCP 的第一次挥手是由客户端向服务器发送的 标志位为  FIN=1 [(发端)发送完成标志位] ACK=1 seq=39 ack=55 len=0\n   \t\n   TCP 的第二次挥手是由服务器向客户端发送的 标志位为  ACK=1 seq=55 ack=40 len=0 \n\n   TCP 的第三次挥手是由服务器向客户端发送的 标志位为  FIN=1 ACK=1 seq=55 ack=40 len=0\n\n   TCP 的第三次挥手是由客户端向服务器发送的 标志位为  ACK=1 seq=40 ack=56 len=0\n\n   白话解释：\n\n   第一次：客户端;我希望断开连接（注意： FIN 标志）\n\n   第二次：服务端：知道了，断开吧\n\n   第三次：服务端：我这边的连接也想断开（注意： FIN 标志）\n\n   第四次：客户端：知道了，断开吧\n\n   附：其实四次挥手来断开连接也不完全可靠，世界上不存在 100% 可靠的通信机制，有兴趣的朋友可以研究一下著名的“两军问题”\n\n4. #### 结尾\n\n   小宝，这次主要是想和大家分享一下 TCP 传输过程中，超时重传和快速回复这部分的小细节，而并没有着重讲解 TCP 的三次握手和四次挥手阶段。小宝尝试亲自去抓取超时重传和快速回复这两部分的包，从实际角度上论证自己的想法的正确性，但这些结论可能还是存在很大的局限性，望各位朋友能以包容的心态，提出小宝的不足，小宝会立刻查询纠正，努力的变黑~\n\n    我是泞小宝. 一个恐惧衰老、执着快乐的小鬼.\n","tags":["NET"]},{"title":"自建CA及颁发SSL证书","url":"/2018/01/02/自建CA及颁发SSL证书/","content":"## 基于 Ubuntu 系统下，自建 CA 及颁发 SSL 证书\n\n### 前言\n\n本文参靠的网站：  \n\n1.[基于 OpenSSL 自建 CA 和颁发 SSL 证书](https://segmentfault.com/a/1190000002569859)\n\n2.[How To Create a SSL Certificate on Apache for Ubuntu 14.04](https://www.digitalocean.com/community/tutorials/how-to-create-a-ssl-certificate-on-apache-for-ubuntu-14-04)\n\n3.[ openssl 总结及私有 CA 的搭建](http://www.178linux.com/10705)\n\n4.[搭建私有 CA 服务器](http://blog.csdn.net/linuxnews/article/details/51011443)\n\n搭建环境：Linux VM-223-65-ubuntu 3.13.0-86-generic\n\n### 使用工具 openssl\n\nopenssl 是什么？\n\nopenssl 是一个开源程序的套件、这个套件有三个部分组成：\n\n一是 libcryto ，这是一个具有通用功能的加密库，里面实现了众多的加密库；\n\n二是 libssl，这个是实现 ssl 机制的，它是用于实现 TLS/SSL 的功能；\n\n三是 openssl，是个多功能命令行工具，它可以实现加密解密，甚至还可以当 CA 来用，可以让你创建证书、吊销证书。\n\n以我的 ubuntu 为例，我的 openssl 的文件目录在  /etc/ssl ，该目录下包含\n\n```\ncert.pem        软链接到certs/ca-bundle.crt\n         \ncerts/          该服务器上的证书存放目录，可以房子自己的证书和内置证书\n\nca-bundle.crt   内置信任的证书\n\nprivate    \t\t证书密钥存放目录\n\nopenssl.cnf     openssl 的 CA 主配置文件\n\ndemoCA \t\t    openssl 的 CA 的证书目录\n```\n\ndemoCA 目录（openssl.cnf 中默认的 CA 目录名）：其下有\n\n```\nnewcerts    存放 CA 签署（颁发）过的数字证书（证书备份目录） \n    \nprivate     用于存放CA的私钥\n\ncrl         吊销的证书\n\nserial      签署证书编号文件\n\nindex.txt   证书缩影数据库\n```\n\n### 名词解释\n\nCA（Certificate Authority）证书颁发机构主要负责证书的颁发、管理以及归档和吊销。证书内包含了拥有证书者的姓名、地址、电子邮件帐号、公钥、证书有效期、发放证书的 CA 、CA 的数字签名等信息。证书主要有三大功能：加密、签名、身份验\n\nSSL (secure socket layer) 安全套接层，其使用对称加密，非对称加密（公钥加密解密），单向加密解密结合证书实现数据传输安全。\n\n### 创建证书\n\n#### 查看配置文件，了解 CA 环境。\n\n```\n命令：\tvim /etc/ssl/openssl.cnf\n\t\n[ CA_default ]\n\ndir\t\t= ./demoCA\t\t# Where everything is kept\ncerts\t\t= $dir/certs\t\t# Where the issued certs are kept\ncrl_dir\t\t= $dir/crl\t\t# Where the issued crl are kept\ndatabase\t= $dir/index.txt\t# database index file.\n#unique_subject\t= no\t\t\t# Set to 'no' to allow creation of\n\t\t\t\t\t\t\t# several ctificates with same subject.\nnew_certs_dir\t= $dir/newcerts\t\t# default place for new certs.\n\ncertificate\t= $dir/cacert.pem \t# The CA certificate\nserial\t\t= $dir/serial \t\t# The current serial number\ncrlnumber\t= $dir/crlnumber\t# the current crl number\n\t\t\t\t\t\t\t\t# must be commented out to leave a V1 CRL\ncrl\t\t= $dir/crl.pem \t\t# The current CRL\nprivate_key\t= $dir/private/cakey.pem# The private key\nRANDFILE\t= $dir/private/.rand\t# private random number file\n\ndefault_days\t= 365\t\t\t# how long to certify for\ndefault_crl_days= 30\t\t\t# how long before next CRL\ndefault_md\t= default\t\t# use public key default MD\npreserve\t= no\t\t\t# keep passed DN ordering\n\n# For the CA policy\n[ policy_match ]\t\t\t\t  注意[ policy_match ]中的设定的匹配规则， 以 CA 根据证书请求来签署证书时报错。\ncountryName\t\t= match\nstateOrProvinceName\t= match\norganizationName\t= match\norganizationalUnitName\t= optional\ncommonName\t\t= supplied\nemailAddress\t\t= optional\n\n[ req_distinguished_name ]\ncountryName\t\t\t= Country Name (2 letter code)\ncountryName_default\t\t= AU\ncountryName_min\t\t\t= 2\ncountryName_max\t\t\t= 2\n\nstateOrProvinceName\t\t= State or Province Name (full name)\nstateOrProvinceName_default\t= Some-State\n\nlocalityName\t\t\t= Locality Name (eg, city)\n\n0.organizationName\t\t= Organization Name (eg, company)\n0.organizationName_default\t= Internet Widgits Pty Ltd\n```\n\n通过我自身配置发现，以上参数均可以不必改变，但需要名录文件路径，以免配置过程出现由路径造成的问题。\n\n#### 初始准备\n\n创建 demoCA 目录 \n\n```\n命令： mkdir demoCA\n```\n\n进入 demoCA 目录 ，在其下创建：private 目录、newcerts 目录、crl 目录及 index.txt、serial 文件\n\n```\n命令：\n\t\tcd demoCA\n\t\tmkdir private newcerts crl \n\t\ttouch index.txt serial\n\t\techo 01 > serial      \t#设定编号初始值\n```\n\n#### 生成根密钥\n\n```\n命令：\n        cd /etc/ssl/demoCA\n\t\topenssl genrsa -out private/cakey.pem 2048 \n\t   \n\t\tgenrsa :生成私钥\n\n\t\t-out ：输出到那里\n\n\t\trsa :提取公钥  \n\n注: 使用命令：( umask 077; openssl genrsa -out private/cakey.pem 2048 ) 可以使 cakey.pem 私钥文件权限为700\n```\n\n#### 生成根证书\n\n```\n命令：\n\t\t\t\tcd /etc/ssl/demoCA     [可省略]\n\t\t\t\topenssl req -new -x509 -key private/cakey.pem -out cacert.pem \n命令解析：\t \n\t\t\t\t req: 生成证书签署请求\n\t\t\t\t -news : 新请求\n\t\t\t\t -key  : 指定私钥文件\n\t\t\t\t -out  : 指定生成证书位置\n\t\t\t\t -x509 : 生成自签署证书，并指定证书类型\n\t\t\t\t -days n : 有效天数\t\n\n\t\t命令效果：（：后为填写内容）\n\n\t\tCountry Name (2 letter code) [XX]:CN            #国家（大写缩写）\n\t\tState or Province Name (full name) []:shannxi   #省份或洲\n\t\tLocality Name (eg, city) [Default City]:xian    #城市\n\t\tOrganization Name (eg, company) [Default Company Ltd]:xiyou   #公司\n\t\tOrganizational Unit Name (eg, section) []:linux  #部门    \n\t\tCommon Name (eg, your name or your server's hostname) []:xxx.xxx.xxx.xxx.#主机\n\t\t\n\t\t主机必须注意：必须与证书所有者能解析到的名字保持一致（即：你服务器的 IP 地址或域名），否则将无法通过验证\n\t\t\n\t\tEmail Address []:                               #邮箱（可以不填）\n\t\t\n\t\t附：以上操作默认选项可通过修改配置文件（/etc/pki/tls/openssl.cnf）修改\n```\n\n#### 为服务器生成 ssl 密钥 [ 以 apache 服务器为例 ]\n\n注：我的 apache 在 /etc/apache2\n\n 创建 ssl 目录\n\n```\n命令：\n\t\t cd /etc/apache2\n\t\t mkdir ssl\n\t\t cd ssl\n\t\t openssl genrsa -out apache.key 2048\n```\n\n### 颁发 SSL 证书\n\n#### 为 apache 服务器生成证书签署请求\n\n```\n命令：openssl req -new -key apache.key -out apache.csr\n\n命令解释如上\n\n注：如果证书的使用者是自己，所填项必须与上面填的一样，负责最后 CA 根据证书请求来签署证书时报错\n    若是证书的使用者是别人，除了 Commone Name 一定要是你要授予证书的服务器域名或主机名，其它内容随便\n\t\n请注意：两者在最后 CA 根据证书请求来签署证书时，使用的方法不同\n\n命令效果：（：后为填写内容）     \nCountry Name (2 letter code) [AU]:CN\t\t\t\t\t\nState or Province Name (full name) [Some-State]:shannxi\nLocality Name (eg, city) []:xian\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:xiyou\nOrganizational Unit Name (eg, section) []:linux\nCommon Name (e.g. server FQDN or YOUR name) []:xxx.xxx.xxx.xxx\nEmail Address []:\n\nPlease enter the following 'extra' attributes\nto be sent with your certificate request\nA challenge password []:（不填）         #证书请求需要加密存放\nAn optional company name []:（不填）\n\n```\n\n#### CA 根据请求来签署证书\n\n1.证书的使用者是自己的情况\n\n把上一步生成的证书请求 csr 文件，发到 CA 服务器上，在CA上执行\n\t\n\n```\n命令：\n  \tcp apache.csr /etc/ssl\n\t  cd /etc/ssl\n  \topenssl ca -in apache.csr -out apache.crt\n\n命令解析：\t\t\n\t ca ： CA 证书相关子命令\n\n```\n\nopenssl ca 默认使用了-cert cacert.pem -keyfile cakey.pem\n\n```\n命令效果：\nUsing configuration from /etc/ssl/openssl.cnf\nCheck that the request matches the signature\nSignature ok\nCertificate Details:\n        Serial Number: 1 (0x1)\n        Validity\n            Not Before: Dec 30 08:49:17 2015 GMT\n            Not After : Dec 27 08:49:17 2025 GMT\n        Subject:\n            countryName               = CN\n            stateOrProvinceName       = shannxi\n            organizationName          = xiyou\n            organizationalUnitName    = linux\n            commonName                = xxx.xxx.xxx.xxx\n        X509v3 extensions:\n            X509v3 Basic Constraints: \n                CA:FALSE\n            Netscape Comment: \n                OpenSSL Generated Certificate\n            X509v3 Subject Key Identifier: \n                D4:83:D5:B4:54:00:C2:FD:BC:70:52:FD:CF:74:0A:69:56:7E:54:02\n            X509v3 Authority Key Identifier: \n                keyid:1B:DB:DC:36:5A:82:A5:AF:1A:A9:9C:7B:71:51:54:44:10:31:C3:4B\n \nCertificate is to be certified until Dec 27 08:49:17 2025 GMT (3650 days)\nSign the certificate? [y/n]:y\n\n```\n\n​\t \n\n```\n1 out of 1 certificate requests certified, commit? [y/n]y\nWrite out database with 1 new entries\nData Base Updated\n\n```\n\n2.证书的使用者是别人\n\n把上一步生成的证书请求 csr 文件，发到 CA 服务器上，在CA上执行\n\t\n\n```\n命令：\n\t\tcp apache.csr /etc/ssl\n\t\tcd /etc/ssl\n\t\topenssl x509 -req -in apache.csr -CA /etc/ssl/demoCA/cacert.pem -CAkey /etc/ssl/demoCA/private/cakey.pem -CAcreateserial -out apache.crt\n\n命令效果：\n\t\tCheck that the request matches the signature\n\t\tSignature ok\n\t\tGetting private key\n\n```\n\n最后将生成的 crt 证书发回 apache 服务器使用\n\n```\n命令：\n\t\tcp  apache.crt /etc/apache2/ssl\n\t\tcd  /etc/apache2/ssl\n\t\tcat  apache.crt\n\t\tcd  /etc/apache2\n\n```\n\n#### 配置 Apache 以使用 SSL\n\n修改 sites-available 子目录中的 default-ssl.conf 文件\n\t\n\n```\n命令：\n\t cd  /etc/apache2/sites-available\n\t\tsudo  vim  default-ssl.conf\n\n   修改内容如下：\n\n\t<IfModule mod_ssl.c>\n\t    <VirtualHost _default_:443>\n\t        DocumentRoot /var/www/html\n\t        ErrorLog ${APACHE_LOG_DIR}/error.log\n\t        CustomLog ${APACHE_LOG_DIR}/access.log combined\n\t        SSLEngine on\n\t        SSLCertificateFile /etc/apache2/ssl/apache.crt                     ***** 需要修改部分\n\t        SSLCertificateKeyFile /etc/apache2/ssl/apache.key             ***** 需要修改部分\n\t        <FilesMatch \"\\.(cgi|shtml|phtml|php)$\">\n\t                        SSLOptions +StdEnvVars\n\t        </FilesMatch>\n\t        <Directory /usr/lib/cgi-bin>\n\t                        SSLOptions +StdEnvVars\n\t        </Directory>\n\t        BrowserMatch \"MSIE [2-6]\" \\\n\t                        nokeepalive ssl-unclean-shutdown \\\n\t                        downgrade-1.0 force-response-1.0\n\t        BrowserMatch \"MSIE [17-9]\" ssl-unclean-shutdown\n\t    </VirtualHost>\n\t</IfModule>\n\n```\n\n### 激活 SSL 虚拟主机\n\n启用 ssl 虚拟主机：\n\n```\n命令：sudo a2ensite default-ssl.conf\n\n```\n\n重启 apache 服务器：\n\n```\n命令：sudo service apache2 restart\n\n```\n\n至此自建 CA 及颁发 SSL 证书完成\n\n### web 服务器上测试\n\n访问你的服务器的域名或公网IP地址，测试配置\n\n```\n方法 ：  https：// 域名 or IP\n\n```\n\n你的浏览器无法验证服务器的身份，因为证书并没有别信任证书机构所认证  [浏览器自身识别权威 CA 机构，由于自建证书并未被权威的 CA 的根证书认证，所以会提示“错误证书”]\n\n证书将无法验证我们的服务器，但证书仍然能够加密通信\n\n点击“继续访问”，通过查看错误证书，可你看到证书的相关信息\n\n并且连接是加密。\n\n### 吊销证书\n\n客户端获取证书 serial\n\n```\n命令：\n\tcd /etc/apache2/ssl\n\topenssl x509 -in apache.crt -noout -serial -subject\n\n```\n\nCA 吊销证书\n\n```\n命令：\n\tcd /etc/ssl/demoCA/newcerts\n\topenssl ca -revoke 01.pem \n\n```\n\nCA 生成吊销证书编号\n\n```\n命令：\n\tcd /etc/ssl/demoCA\n\techo 01 > crlnumber\n\n```\n\nCA 更新证书吊销列表\n\t\n\n```\n命令:\n\tcd crl\n\topenssl ca -gencrl -out ca.crl\n\n```\n\n查看 crl 文件的内容\n\n```\n命令：openssl crl -in /path/to/crlfile.crl -noout -text\n\n```\n\n### 结论\n\nSSL 有助于确保站点和访客之间的通信，但是会对每个访客都会警告浏览器无法验证证书的有效性。\n\n### 后续\n\n以上就是小宝自建 CA 及颁发 SSL 证书的过程，可能其中还存在很大的知识漏洞，但小宝愿意弥补自己的不足，不断进步。\n\n最后希望各位大牛多多纠正小宝的错误，而同小宝一样是小白的朋友看本文过能自己有所帮助。\n\n泞小宝，最求自己的快乐，这就够了。\n","tags":["NET"]},{"title":"基于wordpress的博客搭建手册","url":"/2018/01/01/基于wordpress的博客搭建手册/","content":"# 个人博客搭建\n\n### 第一步：\n\n#### 申请服务器及域名\n\n1.你需要一个服务器和域名（以腾讯云为例）\n\n2.申请域名：\n\n进入腾讯云首页（console.qcloud.com），点击云产品 --> 云服务器 -->选择新建一台云主机（系统选用：ubuntu），并按照自己的需要设置\n\n创建完成后，系统会自动分配给你相应的公网 IP 和内网 IP 例：123.206.xx.xx [公]10.141.xx.xx[内]）\n\n3.域名申请：\n\n返回腾讯云首页，点击云产品 --> 域名管理 -->域名注册（注册的新域名会再提交的一两天后，得到腾讯的认证）\n\n域名注册成功后，点击你的域名右方的 “解析” ，将记录类型的 A 的记录值，改为你的公网 IP.\n\n服务器和域名这两个前提条件解决后，面对这个“崭新”的服务器，是时候给他配置装备了\n\n### 第二步\n\n#### 安装及配置 PHP、apache 和 MYSQL 的环境\n\n附：此部分可以忽略，但小宝建议你还是装上 本部分转自 [[一个你非常值得看的博客]](http://code.leozhang2018.me)\n\n此处介绍 OhMyzsh\n\nZSH 是一个 Unix Shell ，它在兼容标准的 POSIX （对于小宝这种小白来说，它最吸引我的功能就是命令补全错误纠正、简写和漂亮的界面主题）\n\nZsh 很好很强大,但是由于其配置起来过于繁琐复杂,严重的影响使用效率，所以 OhMyzsh 应用而生\n\nOhMyzsh 的好处太多了，小宝就不一一列举了，直接上安装手法\n\n附1.安装 OhMyzsh 前，必须安装 Zsh、curl、git 等 [别问小宝为什么，因为这是最简单的方法，如果你想深入快去看上面那个博客]\n\n附2.首先安装 Zsh,打开 terminal 命令：sudo apt-get install zsh [这可是必须的，小宝第一次就直接装了OhMyzsh 结果呢 自然是被嘲讽了]\n\n附3.接着安装 curl, 命令 sudo apt-get install curl\n\n附4.然后安装 git, 命令 sudo apt-get install git\n\n附5.最后安装 ohmyzsh, 命令: curl -L http://install.ohmyz.sh | sh  [终于可以安装了]\n\n附6.终于安装完成了 T_T .赶快切换默认 shell 为 zsh : chsh -s /bin/zsh \n\n附7.看到了 linux 的命令行，瞬间漂亮了有么有！！ 再告诉你默认主题是 robbyrussell ，可这不是唯一选择哦\n\n主要参考网站：[LAMP的安装教程](https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-14-04)\n\n使用 Xshell5 等软件，远程登陆自己的服务器。\n\n1.对服务器的软件源进行功能更新：sudo apt-get update   [更新软件源]\n\n2.对服务器的系统软件进行功能升级：sudo apt-get upgrade  [更新所有的软件]\n\n小小解析一下：\n\napt-get update ： 访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑\n\napt-get upgrade ： 会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会更新该软件\n\n3.安装 apache \n\n> 命令：sudo apt-get install apache2 （附：一路 Y 下去就好）\n\n安装完后，可通过访问自己的公网 IP ，若出现 Apache2 Ubuntu Default Page 页面，证明 apache 安装完成\n\n4.安装 MYSQL \n\n> 命令： sudo apt-get install mysql-server php5-mysql\n\n> 命令：sudo mysql_secure_installation  可以提高数据库的安全性\n\n出现 MYSQL 的安装界面，按提示输入 root密码（并确认密码）；\n\nChange the root password 选择 n  [是否修改 MYSQL 的 root 用户的密码]\n\nRemove anonymous users 选择 n  [是否移除匿名用户]\n\nDisallow root login remotely 选择 n  [不允许 root 用户的远程登陆数据库]\n\nRemove test database and access to it 选择 n  [移除初始的test数据库（其实都行）]\n\nReload privilege tables now 选择 Y [现在重新加载权限表] （注意哦，这个是 Y）\n\n5.安装 PHP\n\n> 命令： sudo apt-get install php5 libapache2-mod-php5 php5-mcrypt （附： Y 下去就好）\n\n安装完成后，修改 apache 的配置文件，使 apache 执行文件的优先级改变（即:提高 index.php 的优先级）\n\n命令 ： sudo vim /etc/apache2/mods-enabled/dir.conf\n\n修改前：\n\n` <IfModule mod_dir.c> `\n\n```\n\t`    DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm `\n```\n\n` </IfModule> `\n\n------\n\n修改后：\n\n` <IfModule mod_dir.c> `\n\n```\n`    DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm `\n```\n\n` </IfModule>`\n\n修改完成后,保存文件 :wq (保存修改并推出), PHP 的安装大体完成，\n\n若你想使用 PHP 的命令行，使用命令： sudo apt-get install php5-cli\n\n检测 PHP 安装是否正确\n\n编写 index.php 文件（附：检测万要记得删，否则回合以后重名）\n\n内容为：` <?php phpinfo();?> `\n\n访问自己的公网 IP，显示 php 首页，说明安装正常。\n\n### 第三步\n\n#### 安装 wordpress\n\n1.首先从 [wordpress 的中文官网](https://cn.wordpress.org/),下载最新版的 wordpress 4.5.3\n\n2.利用 FileZilla Client 等软件，将 wordpress 4.5.3 的压缩包上传到服务器\n\n3.我的天,这个压缩包是 ZIP 的, tar 命令不能接zip的压缩包，那怎么解压缩呢？ 没办法，只能安装新工具 zip\n\n命令 ：sudo apt-get install zip\n\n安装完成后 ：使用命令 ：unzip -b wordpress4.5.3.zip 解压到 /var/www/html 目录下 \n\n附：小宝对 zip 的命令不是很熟，有兴趣的小伙伴可以自己去看 zip/unzip 的参数及作用，这里我不多说了\n\n解压完成后，\n\n### 第四步\n\n#### 设置 wordpress 的相关条件\n\n1.使用 MYSQL 建立一个 名字为 wordpress 的数据库（别名也可以，但小宝不建议你这么做）\n\n命令 ： mysql -u root -p  输入用户密码\n\n建立数据库 ： create database wordpress\n\n2.建立完成后，在 wordpress 的注册界面，按提示填写你的信息，将自动生出数据库信息\n\n3.将生成的信息写入新建的 wp_config.php 替换 wp_config.example.php,接着点击“立即安装”,此时你的个人博客已经搭好了\n\n4.再次访问你的公网 IP，是不是有一点小激动，第一次我也是这样（害羞），\n\n5.进入设置，常规选项修改 wordpress 的 URL 和站点地址 URL 为你的域名，固定连接选项修改固定链接设置为朴素 \n\n6.最后再说一点吧，将下载的 wordpress 解压到 theme 文件夹中，就可以应用这个主题了哦\n\n### 结尾\n\n#### 感谢\n\n这是小宝第一次写东西，如果你看完了，那真的很感谢你，小宝知道自己还有很大的不足，但小宝愿意在以后的道路中，不断充实自己，写出更好更易懂的文章与大家分享。\n\n","tags":["blog"]}]